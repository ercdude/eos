#+TITLE: Emacs Configuration File
#+AUTHOR: esac
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes

* EOS

  Using emacs (lisp interpreter) as the only IO bridge
  between human and machine.

** Bootstrap
*** Header

    Define the package header to avoid warnings.

    #+BEGIN_SRC emacs-lisp

    ;;; Package --- eos
    ;;; Commentary: ... Present day, present time ....
    ;;; Code:

    #+END_SRC

*** Lexical

    Lexical binding opens up many more opportunities
    for optimization, so programs using it are likely to run
    faster in future Emacs versions.

    Lexical binding is also more compatible with concurrency,
    which was added to Emacs in version 26.1.

    #+BEGIN_SRC emacs-lisp

    ;;; -*- lexical-binding: t -*-

    #+END_SRC

*** Verify
**** Version

     Verify emacs version.

     #+BEGIN_SRC emacs-lisp

     (when (version< emacs-version "26.3")
       (error "This requires Emacs 26.3 and above!"))

     #+END_SRC

*** Literate

    Literate programming is a programming paradigm
    introduced by Donald Knuth in which a computer program is
    given an explanation of its logic in a natural language,
    such as English, interspersed with snippets of macros and
    traditional source code, from which compilable source code
    can be generated.

    Literate programming it's only possible thanks to org-mode.

    #+BEGIN_SRC emacs-lisp

    ;; (require 'org nil t)

    #+END_SRC

*** Garbage Collector

    This works surprisingly well. While the minibuffer is open,
    garbage collection will never occur, but once we
    make a selection, or cancel, garbage collection will kick
    off immediately and then revert back to the default,
    sensible behavior.

**** Customize

     #+BEGIN_SRC emacs-lisp

     ;; threshold inital value
     (setq gc-cons-threshold most-positive-fixnum ; 2^61 bytes
           gc-cons-percentage 0.5)

     #+END_SRC

**** Functions

     #+BEGIN_SRC emacs-lisp

     (defun eos/defer-gc-collection ()
       "Set `gc-cons-threshold' to most positive fix number,
     The largest value that is representable in a Lisp integer."
       (setq gc-cons-threshold most-positive-fixnum))

     (defun eos/reset-gc-collection ()
       "Reset garbage collection."
       (run-at-time 1 nil
                    (lambda ()
                      (setq gc-cons-threshold 16777216))))

     #+END_SRC

**** Hooks

     #+BEGIN_SRC emacs-lisp

     (add-hook 'emacs-startup-hook
               (lambda ()
                 (setq gc-cons-threshold 16777216 ; 16mb
                       gc-cons-percentage 0.1)))

     #+END_SRC

*** Define
**** Aliases

     Define some aliases to improve quality of life.

     #+BEGIN_SRC emacs-lisp

     ;; y or n
     (defalias 'yes-or-no-p 'y-or-n-p)

     #+END_SRC

**** Variables

     #+BEGIN_SRC emacs-lisp

     (defvar eos-file-name-handler-alist
       file-name-handler-alist
       "Save file-name-handler-alist")

     #+END_SRC

**** Keymaps

     Basically we creates new maps prefix maps.

     #+BEGIN_SRC emacs-lisp

     (defvar eos-tags-map
       (make-sparse-keymap)
       "Keymap for tags (navigation) keybinds.")

     (defvar eos-pm-map
       (make-sparse-keymap)
       "Keymap for project manager keybinds.")

     (defvar eos-sc-map
       (make-sparse-keymap)
       "Keymap for syntax check keybinds.")

     (defvar eos-complete-map
       (make-sparse-keymap)
       "Keymap for (complete) keybinds.")

     (defvar eos-window-map
       (make-sparse-keymap)
       "Keymap for window related keybinds.")

     (defvar eos-docs-map
       (make-sparse-keymap)
       "Keymap for documentation keybinds.")

     (defvar eos-find-map
       (make-sparse-keymap)
       "Keymap for find keybinds.")

     (defvar eos-utils-map
       (make-sparse-keymap)
       "Keymap for utils keybinds.")

     (defvar eos-rtags-map
       (make-sparse-keymap)
       "Keymap for rtag minor mode keybinds.")

     #+END_SRC

     Define maps as prefix commands.

     #+BEGIN_SRC emacs-lisp

     (dolist (prefix-map '(eos-tags-map
                           eos-pm-map
                           eos-sc-map
                           eos-docs-map
                           eos-find-map
                           eos-utils-map
                           eos-window-map
                           eos-complete-map
                           eos-rtags-map))
       (define-prefix-command prefix-map))

     #+END_SRC

*** Defer

    Used to seep up the emacs startup time.

**** Clean

     #+BEGIN_SRC emacs-lisp

     ;; clean file-name-handler-alist
     (setq file-name-handler-alist nil)

     #+END_SRC

**** Hooks

     #+BEGIN_SRC emacs-lisp

     ;; restore file-name-handler-alist
     (add-hook 'emacs-startup-hook
               (lambda ()
                 (setq file-name-handler-alist eos-file-name-handler-alist)))

     #+END_SRC

*** Load-path
**** Functions

     #+BEGIN_SRC emacs-lisp

     (require 'cl-seq nil t)

     (defun eos-update-load-path (&rest _)
       "Update `load-path'."
       (dolist (dir '("site-lisp" "lisp"))
         (add-to-list 'load-path
                      (expand-file-name dir user-emacs-directory))))

     (defun eos-add-subdirs-to-load-path (&rest _)
       "Add sub-directories to `load-path'."
       (interactive)
       (let ((default-directory
               (expand-file-name "site-lisp" user-emacs-directory)))
         (normal-top-level-add-subdirs-to-load-path)))

     ;; research
     ;; (cl-remove-duplicates load-path)

     (defun eos-load-file (file)
       "Load FILE if exists."
       (if (file-exists-p file)
           (load (expand-file-name file) t nil nil)
         (message "file %s not found" file)))

     #+END_SRC

**** Enable

     Update `load-path' variables.

     #+BEGIN_SRC emacs-lisp

     ;; update load path
     (eos-update-load-path)
     (eos-add-subdirs-to-load-path)

     #+END_SRC

** Prelude
**** Core

     Core functions must be pure (emacs vanilla and C source)
     and generic.

***** Call

      #+BEGIN_SRC emacs-lisp

      (defun eos-call-proc (name &optional args)
        "Call (execute) a process by NAME with ARGS."
        (if (executable-find name)
            (if args
                (start-process name nil name args)
              (start-process name nil name)))
        nil)

      (defun eos-call-func (func &rest args)
        "Call FUNC with ARGS, if it's bounded."
        (when (fboundp func)
          (funcall func args)))

      #+END_SRC

***** Edit

      #+BEGIN_SRC emacs-lisp

      (defun eos-edit-move-lines (n)
        "Move N lines, up if N is positive, else down."
        (let* (text-start
               text-end
               (region-start (point))
               (region-end region-start)
               swap-point-mark
               delete-latest-newline)

          ;; STEP 1: identifying the text to cut.
          (when (region-active-p)
            (if (> (point) (mark))
                (setq region-start (mark))
              (exchange-point-and-mark)
              (setq swap-point-mark t
                    region-end (point))))

          ;; text-end and region-end
          (end-of-line)

          (if (< (point) (point-max))
              (forward-char 1)
            (setq delete-latest-newline t)
            (insert-char ?\n))
          (setq text-end (point)
                region-end (- region-end text-end))

          ;; text-start and region-start
          (goto-char region-start)
          (beginning-of-line)
          (setq text-start (point)
                region-start (- region-start text-end))

          ;; STEP 2: cut and paste.
          (let ((text (delete-and-extract-region text-start text-end)))
            (forward-line n)
            ;; If the current-column != 0, I have moved the region at the bottom of a
            ;; buffer doesn't have the trailing newline.
            (when (not (= (current-column) 0))
              (insert-char ?\n)
              (setq delete-latest-newline t))
            (insert text))

          ;; STEP 3: Restoring.
          (forward-char region-end)

          (when delete-latest-newline
            (save-excursion
              (goto-char (point-max))
              (delete-char -1)))

          (when (region-active-p)
            (setq deactivate-mark nil)
            (set-mark (+ (point) (- region-start region-end)))
            (if swap-point-mark
                (exchange-point-and-mark)))))

      (defun eos/edit-move-lines-up (n)
        "Move N lines up."
        (interactive "p")
        (if (eq n nil)
            (setq n 1))
        (eos-edit-move-lines (- n)))

      (defun eos/edit-move-lines-down (n)
        "Move N lines down."
        (interactive "p")
        (if (eq n nil)
            (setq n 1))
        (eos-edit-move-lines n))

      (defun eos/edit-move-words-left (n)
        "Move word N times to the left."
        (interactive "p")
        (if (eq n nil)
            (setq n 1))
        (transpose-words (- n)))

      (defun eos/edit-indent-buffer ()
        "Indent the currently visited buffer."
        (interactive)
        (indent-region (point-min) (point-max)))

      (defun eos/edit-indent-region-or-buffer ()
        "Indent a region if selected, otherwise the whole buffer."
        (interactive)
        (save-excursion
          (if (region-active-p)
              (progn
                (indent-region (region-beginning) (region-end))
                (message "Indented selected region."))
            (progn
              (eos/edit-indent-buffer)
              (message "Indented buffer.")))))

      (defun eos/edit-duplicate-current-line-or-region (arg)
        "Duplicates the current line or region ARG times.

      If there's no region, the current line will be duplicated.
      However, if there's a region, all lines that region covers will be duplicated."

        (interactive "p")
        (let (beg end (origin (point)))
          (if (and mark-active (> (point) (mark)))
              (exchange-point-and-mark))
          (setq beg (line-beginning-position))
          (if mark-active
              (exchange-point-and-mark))
          (setq end (line-end-position))
          (let ((region (buffer-substring-no-properties beg end))
                (i arg))
            (while (> i 0)
              (goto-char end)
              (newline)
              (insert region)
              (setq end (point))
              (setq i (1- i)))
            (goto-char (+ origin (* (length region) arg) arg)))))

      #+END_SRC

***** Copy

      #+BEGIN_SRC emacs-lisp

      (defun eos-copy-text-or-symbol-at-point ()
        "Get the text in region or symbol at point.
            If region is active, return the text in that region.  Else if the
            point is on a symbol, return that symbol name.  Else return nil."
        (cond ((use-region-p)
               (buffer-substring-no-properties
                (region-beginning) (region-end)))
              ((symbol-at-point)
               (substring-no-properties (thing-at-point 'symbol)))
              (t
               nil)))

      (defun eos-copy-line (&optional arg)
        "Do a kill-line but copy rather than kill. This function directly calls
      kill-line, so see documentation of kill-line for how to use it including prefix
      argument and relevant variables. This function works by temporarily making the
      buffer read-only."
        (interactive "P")
        (let ((buffer-read-only t)
              (kill-read-only-ok t))
          (kill-line arg))
        (move-beginning-of-line nil))

      #+END_SRC

***** Move

      #+BEGIN_SRC emacs-lisp

      (defun eos/move-beginning-of-line (arg)
        "Move point back to indentation(ARG) start, or line(ARG) start."
        (interactive "^p")
        (setq arg (or arg 1))

        ;; Move lines first
        (when (/= arg 1)
          (let ((line-move-visual nil))
            (forward-line (1- arg))))

        (let ((orig-point (point)))
          (back-to-indentation)
          (when (= orig-point (point))
            (move-beginning-of-line 1))))

      #+END_SRC

***** Kill

      #+BEGIN_SRC emacs-lisp

      (defun eos-kill-buffer (buffer-name)
        "Kill BUFFER-NAME if exists."
        (when (get-buffer buffer-name)
          (kill-buffer buffer-name)))

      (defun eos/kill-current-buffer ()
        "Kill the current buffer without prompting."
        (interactive)
        (kill-buffer (current-buffer)))

      #+END_SRC

***** Files

      #+BEGIN_SRC emacs-lisp

      (defun eos-mkdir (dir)
        "Create DIR in the file system."
        (when (and (not (file-exists-p dir))
                   (make-directory dir :parents))))

      #+END_SRC

***** Search

      #+BEGIN_SRC emacs-lisp

      (defun eos/search-keymaps (key)
        "Search for KEY in all known keymaps.
      Keymaps list will be printed on *Messages* buffer."
        (interactive "kPress key: ")
        (mapatoms (lambda (ob)
                    (when (and (boundp ob) (keymapp (symbol-value ob)))
                      (when (functionp (lookup-key (symbol-value ob) key))
                        (message "%s" ob))))))

      #+END_SRC

***** Utils

      #+BEGIN_SRC emacs-lisp

      (defun eos/set-frame-transparency (alpha)
        "Set transparency level defined by ALPHA in current frame."
        (interactive "nAlpha: ")
        (let ((alpha (or alpha 1.0)))
          (if (executable-find "transset")
              (async-shell-command (format "transset -a %.1f" alpha))
            (error "Transset not found"))))

      #+END_SRC

**** Theme

     Add theme directory to load-path and load the
     default theme.

     #+BEGIN_SRC emacs-lisp

     ;; add eos-theme-dir to theme load path
     (add-to-list 'custom-theme-load-path
                  (concat user-emacs-directory "themes"))

     ;; load theme
     (load-theme 'mesk-term t)

     #+END_SRC

**** Clean
***** Esc

      Clean/unbind keys from esc-map.

      #+BEGIN_SRC emacs-lisp

      ;; clean esc map
      (define-key esc-map (kbd "ESC") nil)
      (define-key esc-map (kbd "<f10>") nil)

      #+END_SRC

***** Ctl-x

      Clean/unbind keys from ctl-x-map.

      #+BEGIN_SRC emacs-lisp

      ;; unbind
      ;; (define-key ctl-x-map (kbd "C-SPC") nil)
      ;; (define-key ctl-x-map (kbd "C-=") nil)
      ;; (define-key ctl-x-map (kbd "C-0") nil)
      ;; (define-key ctl-x-map (kbd "C--") nil)
      ;; (define-key ctl-x-map (kbd "ESC") nil)
      ;; (define-key ctl-x-map (kbd ".") nil)
      ;; (define-key ctl-x-map (kbd "C-l") nil)
      ;; (define-key ctl-x-map (kbd "C-x") nil)
      ;; (define-key ctl-x-map (kbd "C-<left>") nil)
      ;; (define-key ctl-x-map (kbd "C-<right>") nil)
      ;; (define-key ctl-x-map (kbd "C-<up>") nil)
      ;; (define-key ctl-x-map (kbd "C-<down>") nil)
      (define-key ctl-x-map (kbd "<right>") nil)
      (define-key ctl-x-map (kbd "<left>") nil)

      (define-key ctl-x-map (kbd "C-o") nil)
      (define-key ctl-x-map (kbd "C-d") nil)
      (define-key ctl-x-map (kbd "C-c") nil)
      (define-key ctl-x-map (kbd "C-j") nil)
      (define-key ctl-x-map (kbd "C-+") nil)
      (define-key ctl-x-map (kbd "C-a") nil)
      (define-key ctl-x-map (kbd "C-r") nil)
      (define-key ctl-x-map (kbd "C-n") nil)
      (define-key ctl-x-map (kbd "C-z") nil)
      (define-key ctl-x-map (kbd "C-p") nil)
      (define-key ctl-x-map (kbd "C-h") nil)
      (define-key ctl-x-map (kbd "C-u") nil)
      (define-key ctl-x-map (kbd "C-\@") nil)
      (define-key ctl-x-map (kbd "M-:") nil)

      (define-key ctl-x-map (kbd "RET") nil)
      (define-key ctl-x-map (kbd "`") nil)
      (define-key ctl-x-map (kbd "]") nil)
      ;; (define-key ctl-x-map (kbd "[") nil)
      (define-key ctl-x-map (kbd ")") nil)
      (define-key ctl-x-map (kbd "(") nil)
      (define-key ctl-x-map (kbd "<") nil)
      (define-key ctl-x-map (kbd ">") nil)
      (define-key ctl-x-map (kbd "\@") nil)
      (define-key ctl-x-map (kbd "-") nil)
      (define-key ctl-x-map (kbd ";") nil)
      (define-key ctl-x-map (kbd "#") nil)
      (define-key ctl-x-map (kbd "*") nil)
      (define-key ctl-x-map (kbd "'") nil)
      (define-key ctl-x-map (kbd "$") nil)
      (define-key ctl-x-map (kbd "{") nil)
      (define-key ctl-x-map (kbd "}") nil)
      (define-key ctl-x-map (kbd "^") nil)
      ;; (define-key ctl-x-map (kbd "n") nil)
      ;; (define-key ctl-x-map (kbd "f") nil)
      (define-key ctl-x-map (kbd "a") nil)
      (define-key ctl-x-map (kbd "h") nil)
      (define-key ctl-x-map (kbd "v") nil)
      (define-key ctl-x-map (kbd "x") nil)
      (define-key ctl-x-map (kbd "X") nil)

      #+END_SRC

***** Minor

      Clean minor-mode-map-alist.

      #+BEGIN_SRC emacs-lisp

      (setq minor-mode-map-alist nil)

      #+END_SRC

***** Global

      Clean/unbind keys from global-map.

      #+BEGIN_SRC emacs-lisp

      ;; unset
      (global-unset-key (kbd "C-z"))
      (global-unset-key (kbd "C-@"))
      (global-unset-key (kbd "C-\\"))
      (global-unset-key (kbd "C-_"))
      (global-unset-key (kbd "M-l"))
      (global-unset-key (kbd "M-h"))
      (global-unset-key (kbd "M-\\"))
      (global-unset-key (kbd "M-$"))
      (global-unset-key (kbd "M-("))
      (global-unset-key (kbd "M-)"))
      (global-unset-key (kbd "M-r"))
      (global-unset-key (kbd "M-{"))
      (global-unset-key (kbd "M-}"))
      (global-unset-key (kbd "S-SPC"))
      (global-unset-key (kbd "<backtap>"))
      (global-unset-key (kbd "M-="))
      (global-unset-key (kbd "M-@"))
      (global-unset-key (kbd "M-~"))

      ;; (global-unset-key (kbd "M-z"))
      ;; (global-unset-key (kbd "M-SPC"))
      ;; (global-unset-key (kbd "M-m"))
      ;; (global-unset-key (kbd "M-k"))
      ;; (global-unset-key (kbd "M-t"))
      ;; (global-unset-key (kbd "M-q"))

      (global-unset-key (kbd "C-M-h"))
      (global-unset-key (kbd "C-M-j"))
      (global-unset-key (kbd "C-M-."))
      (global-unset-key (kbd "C-M-l"))
      (global-unset-key (kbd "C-M-/"))
      (global-unset-key (kbd "C-M-;"))
      (global-unset-key (kbd "C-M-@"))
      (global-unset-key (kbd "C-M-\\"))
      (global-unset-key (kbd "C-M-a"))
      (global-unset-key (kbd "C-M-r"))
      (global-unset-key (kbd "C-M-s"))
      (global-unset-key (kbd "C-M-%"))
      (global-unset-key (kbd "C-M-u"))
      (global-unset-key (kbd "C-M-d"))
      (global-unset-key (kbd "C-M-SPC"))
      (global-unset-key (kbd "C-M-S-v"))

      (global-unset-key (kbd "<C-M-end>"))
      (global-unset-key (kbd "<C-M-home>"))
      (global-unset-key (kbd "<C-S-backspace>"))
      (global-unset-key (kbd "<C-backspace>"))
      (global-unset-key (kbd "<C-delete>"))
      (global-unset-key (kbd "<C-down>"))
      (global-unset-key (kbd "<C-next>"))
      (global-unset-key (kbd "<C-end>"))
      (global-unset-key (kbd "<C-f10>"))
      (global-unset-key (kbd "<M-f10>"))

      (global-unset-key (kbd "<bottom-divider>"))
      (global-unset-key (kbd "<bottom-edge>"))
      (global-unset-key (kbd "<bottom-left-corner>"))
      (global-unset-key (kbd "<bottom-right-corner>"))

      (global-unset-key (kbd "<horizontal-scroll-bar>"))
      (global-unset-key (kbd "<vertical-scroll-bar>"))

      (global-unset-key (kbd "<left-edge>"))
      (global-unset-key (kbd "<right-edge>"))

      (global-unset-key (kbd "<undo>"))
      (global-unset-key (kbd "<find>"))
      (global-unset-key (kbd "<help>"))
      (global-unset-key (kbd "<open>"))
      (global-unset-key (kbd "<again>"))
      (global-unset-key (kbd "<menu>"))
      (global-unset-key (kbd "<header-line>"))
      (global-unset-key (kbd "<mode-line>"))

      (global-unset-key (kbd "<XF86Back>"))
      (global-unset-key (kbd "<XF86Forward>"))
      (global-unset-key (kbd "<XF86WakeUp>"))

      (global-unset-key (kbd "<top-edge>"))
      (global-unset-key (kbd "<top-left-corner>"))
      (global-unset-key (kbd "<top-right-corner>"))

      (global-unset-key (kbd "<mouse-1>"))
      (global-unset-key (kbd "<mouse-2>"))
      (global-unset-key (kbd "<mouse-3>"))
      (global-unset-key (kbd "<mouse-4>"))
      (global-unset-key (kbd "<mouse-5>"))
      (global-unset-key (kbd "<mouse-6>"))
      (global-unset-key (kbd "<mouse-7>"))

      (global-unset-key (kbd "<right-divider>"))
      (global-unset-key (kbd "<vertical-line>"))

      (global-unset-key (kbd "<f10>"))
      (global-unset-key (kbd "<f11>"))
      (global-unset-key (kbd "<f16>"))
      (global-unset-key (kbd "<f18>"))
      (global-unset-key (kbd "<f20>"))

      (global-unset-key (kbd "<drag-mouse-1>"))
      (global-unset-key (kbd "<C-mouse-4>"))
      (global-unset-key (kbd "<C-mouse-5>"))
      (global-unset-key (kbd "<C-mouse-6>"))
      (global-unset-key (kbd "<C-mouse-7>"))
      (global-unset-key (kbd "<M-mouse-1>"))
      (global-unset-key (kbd "<M-mouse-2>"))
      (global-unset-key (kbd "<M-mouse-3>"))
      (global-unset-key (kbd "<S-mouse-3>"))
      (global-unset-key (kbd "<S-mouse-4>"))
      (global-unset-key (kbd "<S-mouse-5>"))
      (global-unset-key (kbd "<S-mouse-6>"))
      (global-unset-key (kbd "<S-mouse-7>"))
      (global-unset-key (kbd "<C-down-mouse-1>"))
      (global-unset-key (kbd "<C-down-mouse-2>"))
      (global-unset-key (kbd "<M-down-mouse-1>"))
      (global-unset-key (kbd "<M-drag-mouse-1>"))
      (global-unset-key (kbd "<S-down-mouse-1>"))

      #+END_SRC

**** Binds

     Fundamental/core binds.

     #+BEGIN_SRC emacs-lisp

     ;; line movement
     (global-set-key (kbd "C-a") 'eos/move-beginning-of-line)
     (global-set-key (kbd "C-e") 'move-end-of-line)

     ;; word movement
     ;; (global-set-key (kbd "C-<left>") 'backward-word)
     ;; (global-set-key (kbd "C-<right>") 'forward-whitespace)

     ;; scroll movement
     (global-set-key (kbd "C-M-v") 'scroll-other-window)
     (global-set-key (kbd "C-M-y") 'scroll-other-window-down)

     ;; edit
     (global-set-key (kbd "M-i") 'eos/edit-indent-region-or-buffer)
     (global-set-key (kbd "M-j") 'eos/edit-duplicate-current-line-or-region)
     (global-set-key (kbd "M-p") 'eos/edit-move-lines-up)
     (global-set-key (kbd "M-n") 'eos/edit-move-lines-down)

     ;; kill
     (define-key ctl-x-map (kbd "k") 'eos/kill-current-buffer)

     ;; mark
     (define-key eos-utils-map (kbd "h") 'mark-whole-buffer)
     (define-key eos-utils-map (kbd "s") 'mark-sexp)
     (define-key eos-utils-map (kbd "p") 'mark-paragraph)
     (define-key eos-utils-map (kbd "w") 'mark-word)

     ;; eos prefixs
     (define-key ctl-x-map (kbd "p") 'eos-pm-map)
     (define-key ctl-x-map (kbd "t") 'eos-tags-map)
     (define-key ctl-x-map (kbd "c") 'eos-utils-map)
     (define-key ctl-x-map (kbd "e") 'eos-sc-map)
     (define-key ctl-x-map (kbd "f") 'eos-find-map)
     (define-key ctl-x-map (kbd "l") 'eos-docs-map)
     (define-key ctl-x-map (kbd "<tab>") 'eos-complete-map)

     #+END_SRC

** Vanilla
*** Cursor

    On a text terminal, the cursor's appearance is controlled by the
    terminal, largely out of the control of Emacs.
    Some terminals offer two different cursors: a visible static
    cursor, and a very visible blinking cursor.
    By default, Emacs uses the very visible cursor, and switches
    to it when you start or resume Emacs. If the variable
    visible-cursor is nil when Emacs starts or resumes, it uses
    the normal cursor.

**** Customize

     #+BEGIN_SRC emacs-lisp

     ;; non-nil means to make the cursor very visible
     (customize-set-variable 'visible-cursor nil)

     #+END_SRC

*** Window

    Emacs windows system.

    Characteristics:

    - Each Emacs window displays one Emacs buffer at any time.
    - A single buffer may appear in more than one window.
    - Emacs can split a frame into two or many windows.
    - Multiple frames always imply multiple windows, because each
      frame has its own set of windows.
    - Each window belongs to one and only one frame.

    Configure/customize windows standard/basic options,
    the description of each one can be found on the
    commentaries.

**** Customize

     #+BEGIN_SRC emacs-lisp

     ;; scroll options
     ;; number of lines of margin at the top and bottom of a window
     (customize-set-variable 'scroll-margin 0)

     ;; scroll up to this many lines, to bring point back on screen
     (customize-set-variable 'scroll-conservatively 100)

     ;; t means point keeps its screen position
     (customize-set-variable 'scroll-preserve-screen-position t)

     ;; non-nil means mouse commands use dialog boxes to ask questions
     (customize-set-variable 'use-dialog-box nil)

     ;; set window margins
     ;; width in columns of left marginal area for display of a buffer
     (customize-set-variable 'left-margin-width 1)

     ;; width in columns of right marginal area for display of a buffer.
     (customize-set-variable 'right-margin-width 1)

     ;; if t, resize window combinations proportionally
     (customize-set-variable 'window-combination-resize t)

     ;; if non-nil ‘display-buffer’ will try to even window sizes
     (customize-set-variable 'even-window-sizes t)

     ;; if non-nil, left and right side windows occupy full frame height
     (customize-set-variable 'window-sides-vertical nil)

     #+END_SRC

**** Binds

     #+BEGIN_SRC emacs-lisp

     ;; binds (global)
     (global-set-key (kbd "s-l") 'shrink-window-horizontally)
     (global-set-key (kbd "s-h") 'enlarge-window-horizontally)
     (global-set-key (kbd "s-j") 'shrink-window)
     (global-set-key (kbd "s-k") 'enlarge-window)

     ;; next and previous buffer (on current window)
     (define-key ctl-x-map (kbd "C-,") 'previous-buffer)
     (define-key ctl-x-map (kbd "C-.") 'next-buffer)

     ;; binds (eos-window prefix map)
     (define-key eos-window-map (kbd "1") 'maximize-window)
     (define-key eos-window-map (kbd "q") 'minimize-window)
     (define-key eos-window-map (kbd "w") 'balance-windows)

     ;; binds ctl-x-map (C-x w)
     (define-key ctl-x-map (kbd "w") 'eos-window-map)

     ;; switch to buffer
     (define-key ctl-x-map (kbd "C-b") 'switch-to-buffer)

     ;; kill buffer and window
     (define-key ctl-x-map (kbd "C-k") 'kill-buffer-and-window)

     #+END_SRC

**** Display

     In its most simplistic form, a frame accommodates always
     one single window that can be used for displaying a buffer.
     As a consequence, it is always the latest call of display-buffer
     that will have succeeded in placing its buffer there.

     #+BEGIN_SRC emacs-lisp

     ;; (add-to-list 'display-buffer-alist
     ;;              '(("\\*Choices\\*"
     ;;                 (display-buffer-below-selected display-buffer-at-bottom)
     ;;                 (inhibit-same-window . t)
     ;;                 (window-height . fit-window-to-buffer))))

     #+END_SRC

*** Windmove

    This package defines a set of routines, windmove-{left,up,right,
    down}, for selection of windows in a frame geometrically.
    For example, `windmove-right' selects the window immediately to the
    right of the currently-selected one.

**** Require

     #+BEGIN_SRC emacs-lisp

     (when (require 'windmove nil t)
       (progn

     #+END_SRC

**** Enable

     #+BEGIN_SRC emacs-lisp

     ;; window move default keybinds (shift-up/down etc..)
     (eos-call-func 'windmove-default-keybindings)))

     #+END_SRC

*** Startup

    Customize/configure: ~startup.el~ related options.

**** Customize

     #+BEGIN_SRC emacs-lisp

     ;; custom
     ;; non-nil inhibits the startup screen.
     (customize-set-variable 'inhibit-startup-screen t)

     ;; non-nil inhibits the startup screen
     (customize-set-variable 'inhibit-startup-message t)

     ;; non-nil inhibits the initial startup echo area message
     (customize-set-variable 'inhibit-startup-echo-area-message t)

     #+END_SRC

*** Buffer

    Configure/customize standard/basic buffer options.

**** Customize

     #+BEGIN_SRC emacs-lisp

     ;; custom
     ;; non-nil means do not display continuation lines.
     (customize-set-variable 'truncate-lines nil)

     ;; sentences should be separated by a single space,
     ;; so treat two sentences as two when filling
     (customize-set-variable 'sentence-end-double-space nil)

     ;; default indent
     ;; distance between tab stops (for display of tab characters), in columns.
     (customize-set-variable 'tab-width 4)

     ;; indentation can insert tabs if this is non-nil.
     (customize-set-variable 'indent-tabs-mode nil)

     ;; kill process not confirmation required
     ;; list of functions called with no args to query before killing a buffer.
     ;; The buffer being killed will be current while the functions are running.
     (customize-set-variable
      'kill-buffer-query-functions
      (remq 'process-kill-buffer-query-function kill-buffer-query-functions))

     ;; non-nil means load prefers the newest version of a file.
     (customize-set-variable 'load-prefer-newer t)

     #+END_SRC

**** Hooks

     #+BEGIN_SRC emacs-lisp

     ;; (add-hook 'buffer-list-update-hook
     ;;           (lambda ()
     ;;             (when (boundp 'eos/big-file-p)
     ;;               (if (eos/big-file-p)
     ;;                   (or display-line-numbers
     ;;                       (setq display-line-numbers 0))))))

     #+END_SRC

*** Ibuffer

    A major mode for viewing a list of buffers.
    In Ibuffer, you can conveniently perform many operations on the
    currently open buffers, in addition to filtering your view to a
    particular subset of them, and sorting by various criteria.

**** Require

     #+BEGIN_SRC emacs-lisp

     (when (require 'ibuffer nil t)
       (progn

     #+END_SRC

**** Customize

     #+BEGIN_SRC emacs-lisp

     ;; the criteria by which to sort the buffers
     (customize-set-variable 'ibuffer-default-sorting-mode 'filename/process)

     ;; if non-nil, display the current Ibuffer buffer itself
     (customize-set-variable 'ibuffer-view-ibuffer t)

     #+END_SRC

**** Display

     #+BEGIN_SRC emacs-lisp

     #+END_SRC

**** Binds

     #+BEGIN_SRC emacs-lisp

     (define-key ctl-x-map (kbd "b") 'ibuffer)))

     #+END_SRC

*** Hideshow

    Minor mode to hide and show code and comment blocks.

**** Require

     #+BEGIN_SRC emacs-lisp

     (when (require 'hideshow nil t)
       (progn

     #+END_SRC

**** Hooks

     #+BEGIN_SRC emacs-lisp

     (add-hook 'prog-mode-hook 'hs-minor-mode)

     #+END_SRC

**** Binds

     #+BEGIN_SRC emacs-lisp

     ;; ctl-x-map
     (define-key ctl-x-map (kbd "[") 'hs-toggle-hiding)))

     #+END_SRC

*** Minibuffer

    The “minibuffer” is where Emacs commands read complicated arguments,
    such as file names, buffer names, Emacs command names, or Lisp
    expressions.  We call it the “minibuffer” because it’s a special-purpose
    buffer with a small amount of screen space.  You can use the usual Emacs
    editing commands in the minibuffer to edit the argument text.

    When the minibuffer is in use, it appears in the echo area, with a
    cursor. The minibuffer starts with a “prompt”, usually ending with
    a colon.

**** Require

     #+BEGIN_SRC emacs-lisp

     (when (require 'minibuffer nil t)
       (progn

     #+END_SRC

**** Customize

     #+BEGIN_SRC emacs-lisp

     ;; non-nil means to allow minibuffer commands while in the minibuffer
     (customize-set-variable 'enable-recursive-minibuffers nil)

     ;; if non-nil, `read-answer' accepts single-character answers
     (customize-set-variable 'read-answer-short t)

     ;; non-nil means completion ignores case when reading a buffer name
     (customize-set-variable 'read-buffer-completion-ignore-case t)

     ;; non-nil means when reading a file name completion ignores case
     (customize-set-variable 'read-file-name-completion-ignore-case t)

     ;; number of completion candidates below which cycling is used
     (customize-set-variable 'completion-cycle-threshold nil)

     ;; treat the SPC or - inserted by `minibuffer-complete-word as delimiters
     (customize-set-variable 'completion-pcm-complete-word-inserts-delimiters t)

     ;; a string of characters treated as word delimiters for completion
     (customize-set-variable 'completion-pcm-word-delimiters "-_./:| ")

     ;; non-nil means show help message in *Completions* buffer
     (customize-set-variable 'completion-show-help nil)

     ;; non-nil means automatically provide help for invalid completion input
     (customize-set-variable 'completion-auto-help 'lazy)

     ;; list of completion styles to use: see `completion-styles-alist variable
     (customize-set-variable 'completion-styles '(partial-completion substring initials))

     ;; list of category-specific user overrides for completion styles.
     (customize-set-variable 'completion-category-overrides
                             '((file (styles initials basic))
                               (buffer (styles initials basic))
                               (info-menu (styles basic))))

     ;; define the appearance and sorting of completions
     (customize-set-variable 'completions-format 'vertical)

     ;; non-nil means when reading a file name completion ignores case
     (customize-set-variable 'read-file-name-completion-ignore-case t)

     ;; how to resize mini-windows (the minibuffer and the echo area)
     ;; a value of t means resize them to fit the text displayed in them
     (customize-set-variable 'resize-mini-windows nil)

     ;; if non-nil, shorten "(default ...)" to "[...]" in minibuffer prompts
     (customize-set-variable 'minibuffer-eldef-shorten-default t)

     ;; non-nil means to delete duplicates in history
     (customize-set-variable 'history-delete-duplicates t)))

     #+END_SRC

**** Functions

     #+BEGIN_SRC emacs-lisp

     (defun eos/focus-minibuffer ()
       "Focus the active minibuffer.

     Bind this to `completion-list-mode-map' to easily jump
     between the list of candidates present in the \\*Completions\\*
     buffer and the minibuffer."

       (interactive)
       (let ((mini (active-minibuffer-window)))
         (when mini
           (select-window mini))))

     (defun eos/focus-minibuffer-or-completions ()
       "Focus the active minibuffer or the \\*Completions\\*.

           If both the minibuffer and the Completions are present, this
           command will first move per invocation to the former, then the
           latter, and then continue to switch between the two.

           The continuous switch is essentially the same as running
           `eos/focus-minibuffer' and `switch-to-completions' in
           succession."
       (interactive)
       (let* ((mini (active-minibuffer-window))
              (completions (get-buffer-window "*Completions*")))
         (cond ((and mini
                     (not (minibufferp)))
                (select-window mini nil))
               ((and completions
                     (not (eq (selected-window)
                              completions)))
                (select-window completions nil)))))

     #+END_SRC

**** Hooks

     #+BEGIN_SRC emacs-lisp

     ;; defer garbage collection
     (add-hook 'minibuffer-setup-hook 'eos/defer-gc-collection)

     ;; reset threshold to inital value
     (add-hook 'minibuffer-exit-hook 'eos/reset-gc-collection)

     #+END_SRC

**** Binds

     #+BEGIN_SRC emacs-lisp

     ;; minibuffer-local-map
     (define-key minibuffer-local-map (kbd "M-`") 'minibuffer-completion-help)
     (define-key minibuffer-local-map (kbd "<tab>") 'minibuffer-complete)

     ;; research (maybe this is not necessary) (C-k: kill line)
     ;; (define-key minibuffer-local-map (kbd "M-w") 'eos/icomplete/kill-ring-save)

     ;; global-map
     (global-set-key (kbd "ESC ESC") 'eos/focus-minibuffer-or-completions)

     #+END_SRC

**** Enable

     #+BEGIN_SRC emacs-lisp

     ;; if `file-name-shadow-mode' is active, any part of the
     ;; minibuffer text that would be ignored because of this is given the
     ;; properties in `file-name-shadow-properties', which may
     ;; be used to make the ignored text invisible, dim, etc.
     (file-name-shadow-mode -1)

     ;; when active, any recursive use of the minibuffer will show
     ;; the recursion depth in the minibuffer prompt, this is only
     ;; useful if `enable-recursive-minibuffers' is non-nil
     (minibuffer-depth-indicate-mode -1)

     ;; when active, minibuffer prompts that show a default value only show
     ;; the default when it's applicable
     (minibuffer-electric-default-mode 1)

     #+END_SRC

*** Completion

    After you type a few characters, pressing the `complete'
    key inserts the rest of the word you are likely to type.

**** Customize

     #+BEGIN_SRC emacs-lisp

     (when (require 'completion nil t)
       (progn
         ;; custom
         ;; how far to search in the buffer when looking for completions,
         ;; if nil, search the whole buffer
         (customize-set-variable 'completion-search-distance 12000)

         ;; if non-nil, the next completion prompt does a cdabbrev search
         (customize-set-variable 'completion-cdabbrev-prompt-flag nil)

         ;; non-nil means show help message in *Completions* buffer
         (customize-set-variable 'completion-show-help nil)

         ;; non-nil means separator characters mark previous word as used
         (customize-set-variable 'completion-on-separator-characthfer t)

         ;; the filename to save completions to.
         (customize-set-variable
          'save-completions-file-name
          (expand-file-name "cache/completitions" user-emacs-directory))

         ;; non-nil means save most-used completions when exiting emacs
         (customize-set-variable 'save-completions-flag t)

         ;; discard a completion if unused for this many hours.
         ;; (1 day = 24, 1 week = 168)
         ;; if this is 0, non-permanent completions
         ;; will not be saved unless these are used
         (customize-set-variable 'save-completions-retention-time 168)

     #+END_SRC

**** Functions

     #+BEGIN_SRC emacs-lisp

     (defun eos/complete-or-indent ()
       "Complete or indent."
       (interactive)
       (if (looking-at "\\_>")
           (when (fboundp 'complete)
             (complete nil)))
       (indent-according-to-mode))

     (defun eos/complete-at-point-or-indent ()
       "This smart tab is a `minibuffer' compliant.
     It acts as usual in the `minibuffer'.
     Else, if mark is active, indents region.
     Else if point is at the end of a symbol, expands it.
     Else indents the current line."
       (interactive)
       (if (minibufferp)
           (unless (minibuffer-complete)
             (complete-symbol nil))
         (if mark-active
             (indent-region (region-beginning)
                            (region-end))
           (if (looking-at "\\_>")
               (complete-symbol nil)
             (indent-according-to-mode)))))

     (defun eos/complete-buffer-or-indent ()
       "Company (complete anything (in-buffer)) or indent."
       (interactive)
       (if (looking-at "\\_>")
           (progn
             (when (fboundp 'company-complete)
               (funcall 'company-complete)))
         (indent-according-to-mode)))

     #+END_SRC

**** Enable

     #+BEGIN_SRC emacs-lisp

     (eos-call-func 'dynamic-completion-mode 1)

     #+END_SRC

**** Binds

     #+BEGIN_SRC emacs-lisp

     ;; completion-list-mode-map
     (define-key completion-list-mode-map (kbd "h") 'eos/describe-symbol-at-point)
     (define-key completion-list-mode-map (kbd "?") 'eos/describe-symbol-at-point)
     (define-key completion-list-mode-map (kbd "q") 'delete-completion-window)
     (define-key completion-list-mode-map (kbd "d") 'delete-completion-line)
     (define-key completion-list-mode-map (kbd "TAB") 'next-completion)
     (define-key completion-list-mode-map (kbd "SPC") 'previous-completion)
     (define-key completion-list-mode-map (kbd "C-j") 'choose-completion)
     (define-key completion-list-mode-map (kbd "RET") 'choose-completion)
     (define-key completion-list-mode-map (kbd "C-k") 'eos/kill-line)
     (define-key completion-list-mode-map (kbd "ESC ESC") 'eos/focus-minibuffer-or-completions)))

     ;; global-map
     (global-set-key (kbd "<M-tab>") 'eos/complete-at-point-or-indent)
     (global-set-key (kbd "TAB") 'eos/complete-buffer-or-indent)

     #+END_SRC

*** Icomplete

    This package implements a more fine-grained minibuffer
    completion feedback scheme. Prospective completions are concisely
    indicated within the minibuffer itself, with each successive
    keystroke.

**** Require

     #+BEGIN_SRC emacs-lisp

     (require 'icomplete nil t)

     #+END_SRC

**** Customize

     #+BEGIN_SRC emacs-lisp

     ;; custom
     ;; pending-completions number over which to apply `icomplete-compute-delay
     (customize-set-variable 'icomplete-delay-completions-threshold 0)

     ;; maximum number of initial chars to apply `icomplete-compute-delay
     (customize-set-variable 'icomplete-max-delay-chars 0)

     ;; completions-computation stall, used only with large-number completions
     (customize-set-variable 'icomplete-compute-delay 0)

     ;; when non-nil, show completions when first prompting for input
     (customize-set-variable 'icomplete-show-matches-on-no-input t)

     ;; when non-nil, hide common prefix from completion candidates
     (customize-set-variable 'icomplete-hide-common-prefix nil)

     ;; maximum number of lines to use in the minibuffer
     (customize-set-variable 'icomplete-prospects-height 1)

     ;; string used by Icomplete to separate alternatives in the minibuffer
     (customize-set-variable 'icomplete-separator "  •  ")

     ;; specialized completion tables with which `icomplete should operate,
     ;; if this is t, `icomplete operates on all tables
     (customize-set-variable 'icomplete-with-completion-tables t)

     ;; if non-nil, also use icomplete when completing in non-mini buffers
     ;; TODO: research
     (customize-set-variable 'icomplete-in-buffer nil)

     #+END_SRC

     #+RESULTS:

**** Functions
***** Kill-ring

      #+BEGIN_SRC emacs-lisp

      (defun eos/icomplete/kill-ring-save (&optional arg)
        "Expand and save current icomplete match (ARG) to the kill ring.
      With a prefix argument, insert the match to the point in the
      current buffer"
        (interactive "*P")
        (when (and (minibufferp)
                   (bound-and-true-p icomplete-mode))
          (kill-new (field-string-no-properties))
          (if current-prefix-arg
              (progn
                (select-window (get-mru-window))
                (insert (car kill-ring)
                        (abort-recursive-edit))))))

      (defun eos/icomplete/kill-ring ()
        "Insert the selected `kill-ring' item directly at point."
        (interactive)
        (let (candidates)
          ;; set candidates
          (setq candidates
                (cl-loop with cands = (delete-dups kill-ring)
                         for kill in cands
                         unless (or (< (length kill) 4)
                                    (string-match "\\`[\n[:blank:]]+\\'" kill))
                         collect kill))
          ;; if candidates
          (if candidates
              (insert
               (completing-read "Kill-ring: " candidates nil t))
            (message "Mark ring is empty"))))

      #+END_SRC

***** Mark-ring

      #+BEGIN_SRC emacs-lisp

      (defun eos/icomplete-mark-ring-line-string-at-pos (pos)
        "Return line string at position POS."
        (save-excursion
          (goto-char pos)
          (forward-line 0)
          (let ((line (car (split-string (thing-at-point 'line) "[\n\r]"))))
            (remove-text-properties 0 (length line) '(read-only) line)
            (if (string= "" line)
                "<EMPTY LINE>"
              line))))

      (defun eos/icomplete/mark-ring ()
        "Browse `mark-ring' interactively."
        (interactive)
        (let* (candidates)
          (setq candidates
                (cl-loop with marks = (if (mark t)
                                          (cons (mark-marker) mark-ring)
                                        mark-ring)
                         for marker in marks
                         with max-line-number = (line-number-at-pos (point-max))
                         with width = (length (number-to-string max-line-number))
                         for m = (format (concat "%" (number-to-string width) "d: %s")
                                         (line-number-at-pos marker)
                                         (eos/icomplete-mark-ring-line-string-at-pos marker))
                         unless (and recip (assoc m recip))
                         collect (cons m marker) into recip
                         finally return recip))
          (if candidates
              (progn
                (let (candidate)
                  (setq candidate (completing-read "Mark-ring: " candidates nil t))
                  (goto-char (cdr (assoc candidate candidates))))))
          (message "Mark ring is empty")))

      #+END_SRC

***** Toggle

      #+BEGIN_SRC emacs-lisp

      (defun eos/icomplete/toggle-completion-styles (&optional arg)
        "Toggle between completion styles.
      With pregix ARG use basic completion instead.
      These styles are described in `completion-styles-alist'."
        (interactive "*P")
        (when (and (minibufferp)
                   (bound-and-true-p icomplete-mode))
          (let* ((completion-styles-original completion-styles)
                 (basic    '(basic emacs22))
                 (initials '(initials substring partial-completion))
                 (prefix   '(partial-completion substring initials)))

            ;; choose basic, initials or prefix
            (if current-prefix-arg
                (setq-local completion-styles basic)
              (progn
                (if (not (eq (car completion-styles) 'initials))
                    (setq-local completion-styles initials)
                  (setq-local completion-styles prefix))))

            ;; show which current completion style
            (message "Completion style: %s "
                     (format "%s" (car completion-styles))))))

      #+END_SRC

**** Binds

     #+BEGIN_SRC emacs-lisp

     (when (boundp 'icomplete-minibuffer-map)
       (progn
         (define-key icomplete-minibuffer-map (kbd "C-j") 'icomplete-force-complete-and-exit)
         (define-key icomplete-minibuffer-map (kbd "C-f") 'icomplete-forward-completions)
         (define-key icomplete-minibuffer-map (kbd "C-b") 'icomplete-backward-completions)

         ;; toogle styles
         (define-key icomplete-minibuffer-map (kbd "C-,") 'eos/icomplete/toggle-completion-styles)

         ;; basic
         (define-key icomplete-minibuffer-map (kbd "C-.")
           (lambda ()
             (interactive)
             (let ((current-prefix-arg t))
               (funcall 'eos/icomplete/toggle-completion-styles))))))

     ;; eos-utils-map
     (define-key eos-utils-map (kbd "m") 'eos/icomplete/mark-ring)

     ;; global-map
     (global-set-key (kbd "M-y") 'eos/icomplete/kill-ring)

     #+END_SRC

**** Enable

     #+BEGIN_SRC emacs-lisp

     ;; enable (global)
     (icomplete-mode 1)

     #+END_SRC

*** Dabbrev

    The purpose with this package is to let you write just a few
    characters of words you've written earlier to be able to expand
    them.

**** Require

     #+BEGIN_SRC emacs-lisp

     (when (require 'dabbrev nil t)
       (progn

     #+END_SRC

**** Customize

     #+BEGIN_SRC emacs-lisp

     ;; non-nil means case sensitive search.
     (customize-set-variable 'dabbrev-upcase-means-case-search t)

     ;; whether dabbrev treats expansions as the same if they differ in case
     ;; a value of nil means treat them as different.
     (customize-set-variable 'dabbrev-case-distinction t)))

     #+END_SRC

*** Hippie-exp
**** Require

     #+BEGIN_SRC emacs-lisp

     (require 'hippie-exp nil t)

     #+END_SRC

**** Binds

     #+BEGIN_SRC emacs-lisp

     (define-key eos-complete-map (kbd "/") 'hippie-expand)

     #+END_SRC

*** Coding-system

    Configure/set coding-system (UTF8), everywhere!

**** Customize

     #+BEGIN_SRC emacs-lisp

     ;; coding system to use with system messages
     (customize-set-variable 'locale-coding-system 'utf-8)

     ;; coding system to be used for encoding the buffer contents on saving
     (customize-set-variable 'buffer-file-coding-system 'utf-8)

     ;; add coding-system at the front of the priority list for automatic detection
     (prefer-coding-system 'utf-8)

     ;; set coding system (UFT8)
     (set-language-environment "UTF-8")
     (set-terminal-coding-system 'utf-8)
     (set-keyboard-coding-system 'utf-8)
     (set-selection-coding-system 'utf-8)

     #+END_SRC

*** Simple

    A grab-bag of basic Emacs commands not specifically related to
    some major mode or to file-handling.

**** Require

     #+BEGIN_SRC emacs-lisp

     (when (require 'simple nil t)
       (progn

     #+END_SRC

**** Customize

     #+BEGIN_SRC emacs-lisp

     ;; don't omit information when lists nest too deep
     (customize-set-variable 'eval-expression-print-level nil)

     ;; your preference for a mail composition package
     (customize-set-variable 'mail-user-agent 'message-user-agent)

     #+END_SRC

**** Enable

     #+BEGIN_SRC emacs-lisp

     ;; column number display in the mode line
     (eos-call-func 'column-number-mode 1)

     ;; buffer size display in the mode line
     (eos-call-func 'size-indication-mode 1)))

     #+END_SRC

*** Prog-mode

    Generic programming mode, from which others derive.

    #+BEGIN_SRC emacs-lisp

    (require 'prog-mode nil t)

    #+END_SRC

*** Server

    Allow this Emacs process to be a server for client processes.
    This starts a server communications subprocess through which
    client "editors" can send your editing commands to this
    Emacs job. To use the server, set up the program emacsclient
    in the Emacs distribution as your standard "editor".

**** Require

     #+BEGIN_SRC emacs-lisp

     (when (require 'server nil t)
       (progn

     #+END_SRC

**** Hooks

     #+BEGIN_SRC emacs-lisp

     ;; enable emacs server after startup
     (add-hook 'emacs-startup-hook
               (lambda ()
                 (eos-call-func 'server-start)))))

     #+END_SRC

*** Help

    GNU Emacs's built-in help system, the one invoked by
    M-x help-for-help.

**** Require


     #+BEGIN_SRC emacs-lisp

     (when (require 'help nil t)
       (progn

     #+END_SRC

**** Customize

     #+BEGIN_SRC emacs-lisp

     ;; always select the help window
     (customize-set-variable 'help-window-select t)

     ;; maximum height of a window displaying a temporary buffer.
     (customize-set-variable 'temp-buffer-max-height
                             (lambda
                               (buffer)
                               (if (and (display-graphic-p) (eq (selected-window) (frame-root-window)))
                                   (/ (x-display-pixel-height) (frame-char-height) 4)
                                 (/ (- (frame-height) 4) 4))))

     ;; reference
     ;; (customize-set-variable 'temp-buffer-max-height 12)

     #+END_SRC

**** Enable

     #+BEGIN_SRC emacs-lisp

     (temp-buffer-resize-mode 1)))

     #+END_SRC

*** Help-mode

    Help-mode, which is the mode used by *Help* buffers, and
    associated support machinery, such as adding hyperlinks, etc...

**** Require

     #+BEGIN_SRC emacs-lisp

     (when (require 'help-mode nil t)
       (progn

     #+END_SRC

**** Binds

     #+BEGIN_SRC emacs-lisp

     (when (boundp 'help-mode-map)
       (define-key help-mode-map (kbd "C-j") 'push-button))))

     #+END_SRC

*** Help-fns

    This file contains those help commands which are complicated, and
    which may not be used in every session. For example
    `describe-function' will probably be heavily used when doing elisp
    programming, but not if just editing C files.

**** Require

     #+BEGIN_SRC emacs-lisp

     (when (require 'help-fns nil t)
       (progn

     #+END_SRC

**** Functions

     #+BEGIN_SRC emacs-lisp

     (defun eos/describe-symbol-at-point (&optional arg)
       "Get help (documentation) for the symbol at point as ARG.

     With a prefix argument, switch to the *Help* window.  If that is
     already focused, switch to the most recently used window
     instead."
       (interactive "P")
       (let ((symbol (symbol-at-point)))
         (when symbol
           (describe-symbol symbol)))
       (when current-prefix-arg
         (let ((help (get-buffer-window "*Help*")))
           (when help
             (if (not (eq (selected-window) help))
                 (select-window help)
               (select-window (get-mru-window)))))))))

     #+END_SRC

*** Info

    The GNU Project distributes most of its manuals in the Info format,
    which you read using an Info reader.

**** Require

     #+BEGIN_SRC emacs-lisp

     (when (require 'info nil t)
       (progn

     #+END_SRC

**** Customize

     #+BEGIN_SRC emacs-lisp

     ;; non-nil means don’t record intermediate Info nodes to the history
     (customize-set-variable 'info-history-skip-intermediate-nodes nil)))

     ;; 0 -> means do not display breadcrumbs
     ;; (customize-set-variable 'info-breadcrumbs-depth 0)

     #+END_SRC

*** Fringe

    Contains code to initialize the built-in fringe bitmaps
    as well as helpful functions for customizing the appearance of the
    fringe.

**** Require

     #+BEGIN_SRC emacs-lisp

     (when (require 'fringe nil t)
       (progn

     #+END_SRC

**** Customize

     #+BEGIN_SRC emacs-lisp

     ;; custom
     ;; 0 -> ("no-fringes" . 0), remove ugly icons to represet new lines
     ;; ascii is more than enough to represent this information
     ;; default appearance of fringes on all frame
     (customize-set-variable 'fringe-mode 0)))

     #+END_SRC

*** Files

    Defines most of Emacs's file- and directory-handling functions,
    including basic file visiting, backup generation, link handling,
    ITS-id version control, load- and write-hook handling, and the like.

**** Require

     #+BEGIN_SRC emacs-lisp

     (when (require 'files nil t)
       (progn

     #+END_SRC

**** Customize

     #+BEGIN_SRC emacs-lisp

     ;; control use of version numbers for backup files.
     (customize-set-variable 'version-control t)

     ;; non-nil means always use copying to create backup files
     (customize-set-variable 'backup-by-copying t)

     ;; number of newest versions to keep when a new numbered backup is made
     (customize-set-variable 'kept-new-versions 6)

     ;; number of oldest versions to keep when a new numbered backup is made
     (customize-set-variable 'kept-old-versions 2)

     ;; if t, delete excess backup versions silently
     (customize-set-variable 'delete-old-versions t)

     ;; non-nil means make a backup of a file the first time it is saved
     (customize-set-variable 'make-backup-files nil)

     ;; non-nil says by default do auto-saving of every file-visiting buffer
     (customize-set-variable 'auto-save-default nil)

     ;; most *NIX tools work best when files are terminated
     ;; with a newline
     (customize-set-variable 'require-final-newline t)

     ;; backup directory list
     ;; alist of filename patterns and backup directory names
     (customize-set-variable 'backup-directory-alist '(("" . "~/.emacs.d/backup")))))

     ;; create cache directory
     (eos-mkdir (concat user-emacs-directory "cache"))

     #+END_SRC

*** Isearch

    Incremental search minor mode.

**** Require

     #+BEGIN_SRC emacs-lisp

     (require 'isearch nil t)

     #+END_SRC

*** Ffap

    Command find-file-at-point.
    With a prefix, it behaves exactly like find-file.
    Without a prefix, it first tries to guess a default file or URL
    from the text around the point.

**** Require

     #+BEGIN_SRC emacs-lisp

     (when (require 'ffap nil t)
       (progn

     #+END_SRC

**** Binds

     #+BEGIN_SRC emacs-lisp

     ;; eos-find-map
     (define-key eos-find-map (kbd "f") 'find-file-at-point)
     (define-key eos-find-map (kbd "d") 'dired-at-point)
     (define-key eos-find-map (kbd "C-d") 'ffap-list-directory)))

     #+END_SRC

*** Locate

    Locate.el provides an interface to a program which searches a
    database of file names. By default, this program is the GNU locate
    command, but it could also be the BSD-style find command, or even a
    user specified command.

**** Require

     #+BEGIN_SRC emacs-lisp

     (when (require 'locate nil t)
       (progn

     #+END_SRC

**** Binds

     #+BEGIN_SRC emacs-lisp

     (define-key eos-find-map (kbd "l") 'locate)))

     #+END_SRC

*** Replace

    This package supplies the string and regular-expression replace functions
    documented in the Emacs user's manual.

**** Require

     #+BEGIN_SRC emacs-lisp

     (when (require 'replace nil t)
       (progn

     #+END_SRC

**** Functions

     #+BEGIN_SRC emacs-lisp

     (defun eos/occur-at-point ()
       "Occur with symbol or region as its arguments."
       (interactive)
       (let* ((bounds (if (use-region-p)
                          (cons (region-beginning) (region-end))
                        (bounds-of-thing-at-point 'symbol)))
              (string nil))
         (unless bounds
           (setq string (read-string "Occur: ")))
         (if bounds
             (occur (buffer-substring-no-properties
                     (car bounds) (cdr bounds)))
           (if string
               (occur string)
             (message "Missing candidate")))))

     #+END_SRC

**** Binds

     #+BEGIN_SRC emacs-lisp

     (global-set-key (kbd "M-s M-o") 'eos/occur-at-point)))

     #+END_SRC

*** Recentf

    The recent files list is automatically saved across Emacs
    sessions. You can customize the number of recent files displayed,
    the location of the menu and others options
    (see the source code for details).

**** Require

     #+BEGIN_SRC emacs-lisp

     (require 'recentf nil t)

     #+END_SRC

**** Customize

     #+BEGIN_SRC emacs-lisp

     ;; file to save the recent list into.
     (customize-set-variable
      'recentf-save-file (concat user-emacs-directory "cache/recentf"))

     #+END_SRC

**** Functions

     #+BEGIN_SRC emacs-lisp

     (defun eos/icomplete/recentf-open-file ()
       "Open `recent-list' item in a new buffer.
     The user's $HOME directory is abbreviated as a tilde."
       (interactive)
       (let ((files (mapcar 'abbreviate-file-name recentf-list)))
         (find-file
          (completing-read "Recentf: " files nil t))))

     #+END_SRC

**** Binds

     #+BEGIN_SRC emacs-lisp

     ;; eos-find-map
     (define-key eos-find-map (kbd "C-r") 'recentf-open-files)
     (define-key eos-find-map (kbd "r") 'eos/icomplete/recentf-open-file)

     #+END_SRC

*** Bookmark

    The bookmark list is sorted lexically by default, but you can turn
    this off by setting bookmark-sort-flag to nil. If it is nil, then
    the list will be presented in the order it is recorded
    (chronologically), which is actually fairly useful as well.


**** Require

     #+BEGIN_SRC emacs-lisp

     (when (require 'bookmark nil t)
       (progn

     #+END_SRC

**** Customize

     #+BEGIN_SRC emacs-lisp

     ;; custom
     ;; file in which to save bookmarks by default.
     (customize-set-variable
      'bookmark-default-file (concat user-emacs-directory "cache/bookmarks"))))

     #+END_SRC

*** Savehist

    Many editors (e.g. Vim) have the feature of saving minibuffer
    history to an external file after exit.  This package provides the
    same feature in Emacs.  When set up, it saves recorded minibuffer
    histories to a file (`~/.emacs-history' by default).  Additional
    variables may be specified by customizing
    `savehist-additional-variables'.

**** Require

     #+BEGIN_SRC emacs-lisp

     (when (require 'savehist nil t)
       (progn

     #+END_SRC

**** Customize

     #+BEGIN_SRC emacs-lisp

     ;; file name where minibuffer history is saved to and loaded from.
     (customize-set-variable
      'savehist-file (concat user-emacs-directory "cache/history"))

     ;; if non-nil, save all recorded minibuffer histories.
     (customize-set-variable 'savehist-save-minibuffer-history t)

     #+END_SRC

**** Enable

     #+BEGIN_SRC emacs-lisp

     ;; enable savehist mode
     (eos-call-func 'savehist-mode 1)))

     #+END_SRC

*** Frame

    When Emacs is started on a graphical display, e.g., on the X Window
    System, it occupies a graphical system-level display region.  In this
    manual, we call this a “frame”, reserving the word “window” for the part
    of the frame used for displaying a buffer.

    - A frame initially contains one window, but it can be subdivided
      into multiple windows

    Configure/customize frame related options:

**** Require

     #+BEGIN_SRC emacs-lisp

     (require 'frame nil t)

     #+END_SRC

**** Customize

     #+BEGIN_SRC emacs-lisp

     ;; with some window managers you may have to set this to non-nil
     ;; in order to set the size of a frame in pixels, to maximize
     ;; frames or to make them fullscreen.
     (customize-set-variable 'frame-resize-pixelwise t)

     ;; normalize before maximize
     (customize-set-variable 'x-frame-normalize-before-maximize t)

     ;; set frame title format
     (customize-set-variable 'frame-title-format
                             '((:eval (if (buffer-file-name)
                                          (abbreviate-file-name (buffer-file-name))
                                        "%b"))))

     ;; alist of parameters for the initial X window frame
     (add-to-list 'initial-frame-alist '(fullscreen . fullheight))

     ;; (vertical-scroll-bars)
     ;; (bottom-divider-width . 0)
     ;; (right-divider-width . 6)

     ;; set font by face attribute (reference)
     ;; (set-face-attribute 'default nil :height)

     ;; alist of default values for frame creation
     (add-to-list 'default-frame-alist '(internal-border-width . 2))


     #+END_SRC

**** Functions

     #+BEGIN_SRC emacs-lisp

     (defun eos-set-frame-font (font)
       "Set the default font to FONT."
       (cond ((find-font (font-spec :name font))
              (set-frame-font font nil t))))

     #+END_SRC

**** Hooks

     #+BEGIN_SRC emacs-lisp

     ;; set transparency after a frame is created
     ;; (add-hook 'after-make-frame-functions
     ;;           (lambda (frame)
     ;;             (interactive)
     ;;             (eos/set-frame-transparency 0.9)))

     ;; ;; fix first frame
     ;; (add-hook 'emacs-startup-hook
     ;;           (lambda ()
     ;;             (interactive)
     ;;             (make-frame)
     ;;             (delete-other-frames)))

     #+END_SRC

**** Binds

     #+BEGIN_SRC emacs-lisp

     ;; binds
     (global-set-key (kbd "C-x C-o") 'other-frame)

     #+END_SRC

**** Enable

     #+BEGIN_SRC emacs-lisp

     ;; set frame font
     (eos-set-frame-font "Hermit Light:pixelsize=20")

     ;; enable window divider
     (window-divider-mode)

     ;; disable blink cursor
     (blink-cursor-mode 0)

     #+END_SRC

*** Page

    This package provides the page-oriented movement and
    selection commands documented in the Emacs manual.

**** Require

     #+BEGIN_SRC emacs-lisp

     (when (require 'page nil t)
       (progn


     #+END_SRC

**** Enable

     #+BEGIN_SRC emacs-lisp

     ;; enable narrow functions
     (put 'narrow-to-page 'disabled nil)
     (put 'narrow-to-region 'disabled nil)))

     #+END_SRC

*** Kmacro

    The kmacro package provides the user interface to emacs' basic
    keyboard macro functionality.  With kmacro, two function keys are
    dedicated to keyboard macros, by default F3 and F4.

**** Require

     #+BEGIN_SRC emacs-lisp

     (when (require 'kmacro nil t)
       (progn

     #+END_SRC

**** Binds

     #+BEGIN_SRC emacs-lisp

     (define-key ctl-x-map (kbd "m") 'kmacro-keymap)))

     #+END_SRC

*** Paren

    It will display highlighting on whatever paren matches the one
    before or after point.

**** Require

     #+BEGIN_SRC emacs-lisp

     (when (require 'paren nil t)
       (progn

     #+END_SRC

**** Enable

     #+BEGIN_SRC emacs-lisp

     ;; visualization of matching parens
     (eos-call-func 'show-paren-mode 1)))

     #+END_SRC

*** Time

    Facilities to display current time/date and a new-mail indicator
    in the Emacs mode line.

**** Require

     #+BEGIN_SRC emacs-lisp

     (when (require 'time nil t)
       (progn

     #+END_SRC

**** Customize

     #+BEGIN_SRC emacs-lisp

     ;; seconds between updates of time in the mode line.
     (customize-set-variable 'display-time-interval 15)

     ;; non-nil indicates time should be displayed as hh:mm, 0 <= hh <= 23
     (customize-set-variable 'display-time-24hr-format t)

     ;; set format time string
     (customize-set-variable 'display-time-format "%H:%M")

     ;; load-average values below this value won’t be shown in the mode line.
     (customize-set-variable 'display-time-load-average-threshold 1.0)

     #+END_SRC

**** Enable

     #+BEGIN_SRC emacs-lisp

     ;; enable display time
     (eos-call-func 'display-time-mode 1)))

     #+END_SRC

*** Tmm

    This package provides text mode access to the menu bar.

**** Require

     #+BEGIN_SRC emacs-lisp

     (require 'tmm nil t)

     #+END_SRC

*** Tool-bar

    Provides `tool-bar-mode' to control display of the tool-bar and
    bindings for the global tool bar with convenience functions
    `tool-bar-add-item' and `tool-bar-add-item-from-menu'.

    Tool bar in all graphical frames disabled by default.

**** Require

     #+BEGIN_SRC emacs-lisp

     (when (require 'tool-bar nil t)
       (progn

     #+END_SRC

**** Disable

     #+BEGIN_SRC emacs-lisp

     ;; disable
     (eos-call-func 'tool-bar-mode 0)))

     #+END_SRC

*** Tooltip

    When this global minor mode is enabled, Emacs displays help
    text (e.g. for buttons and menu items that you put the mouse on)
    in a pop-up window.

**** Require

     #+BEGIN_SRC emacs-lisp

     (when (require 'tooltip nil t)
       (progn

     #+END_SRC

**** Disable

     #+BEGIN_SRC emacs-lisp

     (eos-call-func 'tooltip-mode 0)))

     #+END_SRC

*** Menu-bar

    Each Emacs frame normally has a "menu bar" at the top which you can use
    to perform common operations. There's no need to list them here, as you
    can more easily see them yourself.

    Disabled by default.

**** Require

     #+BEGIN_SRC emacs-lisp

     (when (require 'menu-bar nil t)
       (progn

     #+END_SRC

**** Disable

     #+BEGIN_SRC emacs-lisp

     (eos-call-func 'menu-bar-mode 0)))

     #+END_SRC

*** Scroll-bar

    Specify whether to have vertical scroll bars, and on which side.
    Disabled by default.

**** Require

     #+BEGIN_SRC emacs-lisp

     (when (require 'scroll-bar nil t)
       (progn

     #+END_SRC

**** Binds

     #+BEGIN_SRC emacs-lisp

     ;; disable scroll bar
     (eos-call-func 'scroll-bar-mode 0)))

     #+END_SRC

*** Hl-line

    Provides a local minor mode (toggled by M-x hl-line-mode) and
    a global minor mode (toggled by M-x global-hl-line-mode) to
    highlight, on a suitable terminal, the line on which point is.

**** Require

     #+BEGIN_SRC emacs-lisp

     (when (require 'hl-line nil t)
       (progn

     #+END_SRC

**** Enable

     #+BEGIN_SRC emacs-lisp

     ;; enable highlight line
     (eos-call-func 'global-hl-line-mode 1)))

     #+END_SRC

*** Linum

    Display line numbers for the current buffer.

**** Require

     #+BEGIN_SRC emacs-lisp

     (when (require 'linum nil t)
       (progn

     #+END_SRC

**** Customize

     #+BEGIN_SRC emacs-lisp

     ;; format used to display line numbers.
     (customize-set-variable 'linum-format " %2d ")))

     #+END_SRC

*** Display-linum

    Display line numbers in the buffer.
    Provides a minor mode interface for `display-line-numbers'.

**** Require

     #+BEGIN_SRC emacs-lisp

     (when (require 'display-line-numbers nil t)
       (progn

     #+END_SRC

**** Hooks

     #+BEGIN_SRC emacs-lisp

     (add-hook 'prog-mode-hook 'display-line-numbers-mode)))

     #+END_SRC

**** Enable

     #+BEGIN_SRC emacs-lisp

     ;; (eos-call-func 'global-display-line-numbers-mode 1)))

     #+END_SRC

*** Whitespace

    This package is a minor mode to visualize and clean
    blanks (TAB, (HARD) SPACE and NEWLINE).

**** Require

     #+BEGIN_SRC emacs-lisp

     (when (require 'whitespace nil t)
       (progn

     #+END_SRC

**** Hooks

     #+BEGIN_SRC emacs-lisp

     ;; clean whitespace and newlines before buffer save
     (add-hook 'before-save-hook #'whitespace-cleanup)

     #+END_SRC

**** Binds

     #+BEGIN_SRC emacs-lisp

     ;; binds
     (define-key ctl-x-map (kbd ".") 'whitespace-mode)))

     #+END_SRC

*** Subword

    This package provides the `subword' minor mode, which merges the
    old remap-based subword.el (derived from cc-mode code) and
    cap-words.el, which takes advantage of core Emacs
    word-motion-customization functionality.

**** Require

     #+BEGIN_SRC emacs-lisp

     (when (require 'subword nil t)
       (progn

     #+END_SRC

**** Enable

     #+BEGIN_SRC emacs-lisp

     (eos-call-func 'global-subword-mode 1)))

     #+END_SRC

*** Face-remap

    This package defines some simple operations that can be used for
    maintaining the `face-remapping-alist' in a cooperative way.
    This is especially important for the `default' face.

**** Require

     #+BEGIN_SRC emacs-lisp

     (when (require 'face-remap nil t)
       (progn

     #+END_SRC

**** Binds

     #+BEGIN_SRC emacs-lisp

     ;; ctl-x-map (C-x)
     (define-key ctl-x-map (kbd "=") 'text-scale-adjust)))

     #+END_SRC

*** Custom

    Emacs has many settings which you can change. Most settings are
    customizable variables, which are also called user options.
    There is a huge number of customizable variables,
    controlling numerous aspects of Emacs behavior.

**** Require

     #+BEGIN_SRC emacs-lisp

     (when (require 'custom nil t)
       (progn

     #+END_SRC

**** Customize

     #+BEGIN_SRC emacs-lisp

     ;; file used for storing customization information.
     ;; The default is nil, which means to use your init file
     ;; as specified by ‘user-init-file’.  If the value is not nil,
     ;; it should be an absolute file name.
     (customize-set-variable
      'custom-file (concat (expand-file-name user-emacs-directory) "custom.el"))))

     #+END_SRC

**** Load

     #+BEGIN_SRC emacs-lisp

     ;; load custom-file
     ;; (eos-load-file custom-file)

     #+END_SRC

*** Forms

    Forms mode means visiting a data file which is supposed to consist
    of records each containing a number of fields. The records are
    separated by a newline, the fields are separated by a user-defined
    field separator (default: TAB). When shown, a record is
    transferred to an Emacs buffer and presented using a user-defined
    form. One record is shown at a time.

**** Require

     #+BEGIN_SRC emacs-lisp

     (require 'forms nil t)

     #+END_SRC

*** Conf

    This package is designed to edit many similar varieties of
    Configuration and initialization files.

**** Require

     #+BEGIN_SRC emacs-lisp

     (when (require 'conf-mode nil t)
       (progn

     #+END_SRC

**** Enable

     #+BEGIN_SRC emacs-lisp

     (add-to-list 'auto-mode-alist '("\\.compose\\'" . conf-mode))
     (add-to-list 'auto-mode-alist '("\\.dockerfile\\'" . conf-mode))))

     #+END_SRC

*** Mm-bodies

    This library handles MIME body (encode/decode).

    MIME is short for "Multipurpose Internet Mail Extensions".
    This standard is documented in a number of RFCs;
    mainly RFC2045 (Format of Internet Message Bodies),
    RFC2046 (Media Types), RFC2047 (Message Header Extensions for
    Non-ASCII Text),  RFC2048 (Registration Procedures),
    RFC2049 (Conformance Criteria and Examples).

    It is highly recommended that anyone who intends writing
    MIME-compliant software read at least RFC2045 and RFC2047.

**** Require

      #+BEGIN_SRC emacs-lisp

      (require 'mm-bodies nil t)

      #+END_SRC

**** Customize

      #+BEGIN_SRC emacs-lisp

      (add-to-list 'mm-body-charset-encoding-alist '(utf-8 . base64))

      #+END_SRC

*** Network
**** Imap

     This library provides an interface for talking to
     IMAP servers.

***** Require

     #+BEGIN_SRC emacs-lisp

     (require 'imap nil t)

     #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      (customize-set-variable 'imap-read-timeout 2)

      #+END_SRC

**** Nnimap

     Nnimap library provides interfaces Gnus with IMAP servers.

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'nnimap nil t)

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; limit the number of articles to look for after moving an article
      (customize-set-variable 'nnimap-request-articles-find-limit nil)

      #+END_SRC

**** Smtpmail

     This library provides functionalities related to send mail
     through STMP protocol.

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'smtpmail nil t)

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; specify default SMTP server
      ;; (customize-set-variable 'smtpmail-default-smtp-server "smtp.gmail.com")

      ;; the name of the host running SMTP server
      ;; (customize-set-variable 'smtpmail-smtp-server "smtp.gmail.com")

      ;; type of SMTP connections to use
      (customize-set-variable 'smtpmail-stream-type 'ssl)

      ;; smtp service port number
      (customize-set-variable 'smtpmail-smtp-service 465)

      ;; non-nil means mail is queued; otherwise it is sent immediately.
      (customize-set-variable 'smtpmail-queue-mail nil)

      #+END_SRC

** Applications
*** Xorg
**** Exwm

     EXWM (Emacs X Window Manager) is a full-featured tiling X window manager
     for Emacs built on top of [XELB].

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'exwm nil t)
      (require 'exwm-core nil t)
      (require 'exwm-config nil t)
      (require 'exwm-workspace nil t)

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; set exwm workspaces number
      (customize-set-variable 'exwm-workspace-number 0)

      ;; show workspaces in all buffers
      (customize-set-variable 'exwm-workspace-show-all-buffers t)

      ;; non-nil to allow switching to buffers on other workspaces
      (customize-set-variable 'exwm-layout-show-all-buffers t)

      ;; non-nil to force managing all X windows in tiling layout.
      (customize-set-variable 'exwm-manage-force-tiling t)

      ;; exwn global keybindings
      (customize-set-variable 'exwm-input-global-keys
                              `(([?\s-r] . exwm-reset)
                                ([?\s-q] . exwm-input-toggle-keyboard)
                                ;; ([?\s-w] . exwm-workspace-switch)
                                ;; ([?\s-k] . exwm-workspace-delete)
                                ;; ([?\s-a] . exwm-workspace-swap)

                                ;; create and switch to workspaces
                                ,@(mapcar (lambda (i)
                                            `(,(kbd (format "s-%d" i)) .
                                              (lambda ()
                                                (interactive)
                                                (exwm-workspace-switch-create ,i))))
                                          (number-sequence 0 3))))

      ;; The following example demonstrates how to use simulation keys to mimic
      ;; the behavior of Emacs.  The value of `exwm-input-simulation-keys` is a
      ;; list of cons cells (SRC . DEST), where SRC is the key sequence you press
      ;; and DEST is what EXWM actually sends to application.  Note that both SRC
      ;; and DEST should be key sequences (vector or string).
      (customize-set-variable 'exwm-input-simulation-keys
                              '(
                                ;; movement
                                ([?\C-b] . [left])
                                ([?\M-b] . [C-left])
                                ([?\C-f] . [right])
                                ([?\M-f] . [C-right])
                                ([?\C-p] . [up])
                                ([?\C-n] . [down])
                                ([?\C-a] . [home])
                                ([?\C-e] . [end])
                                ([?\M-v] . [prior])
                                ([?\C-v] . [next])
                                ([?\C-d] . [delete])
                                ([?\C-k] . [S-end delete])

                                ;; firefox temporary
                                ([?\C-o] . [C-prior]) ; change tab mapping
                                ([?\C-k] . [C-w]) ; close tab mapping
                                ([?\C-j] . [return]) ; close tab mapping

                                ;; cut/paste.
                                ([?\C-w] . [?\C-x])
                                ([?\M-w] . [?\C-c])
                                ([?\C-y] . [?\C-v])

                                ;; Escape (cancel)
                                ([?\C-g] . [escape])

                                ;; search
                                ([?\C-s] . [?\C-f])))

      #+END_SRC

***** Binds

      #+BEGIN_SRC emacs-lisp

      ;; this little bit will make sure that XF86 keys work in exwm buffers as well
      (if (boundp 'exwm-input-prefix-keys)
          (progn
            (dolist (key '(XF86AudioLowerVolume
                           XF86AudioRaiseVolume
                           XF86PowerOff
                           XF86AudioMute
                           XF86AudioPlay
                           XF86AudioStop
                           XF86AudioPrev
                           XF86AudioNext
                           XF86ScreenSaver
                           XF68Back
                           XF86Forward
                           Scroll_Lock
                           print))
              (cl-pushnew key exwm-input-prefix-keys))))

     (global-set-key (kbd "s-o") 'other-frame)

      #+END_SRC

***** Hooks

      #+BEGIN_SRC emacs-lisp

      ;; set frame opacy
      (add-hook 'exwm-init-hook
                (lambda ()
                  (interactive)
                  (eos/set-frame-transparency 0.9)))

      ;; All buffers created in EXWM mode are named "*EXWM*". You may want to
      ;; change it in `exwm-update-class-hook' and `exwm-update-title-hook', which
      ;; are run when a new X window class name or title is available.  Here's
      ;; some advice on this topic:
      ;; + Always use `exwm-workspace-rename-buffer` to avoid naming conflict.
      ;; + For applications with multiple windows (e.g. GIMP), the class names of
      ;; all windows are probably the same.  Using window titles for them makes
      ;; more sense.

      ;; update the buffer name by X11 window title
      (add-hook 'exwm-update-title-hook
                (lambda ()
                  (exwm-workspace-rename-buffer
                   (concat exwm-class-name "|" exwm-title))))

      #+END_SRC

***** Enable

      #+BEGIN_SRC emacs-lisp

      (eos-call-func 'exwm-enable)

      #+END_SRC

**** Exwm-randr

     This module adds Randr support for EXWM.
     Currently it requires external tools such as xrandr(1)
     to properly configure Randr first.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'exwm-randr nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; monitors: check the xrandr(1) output and use the same name/order
      ;; TODO: create a func that retrieves these values from xrandr
      (customize-set-variable
        'exwm-randr-workspace-monitor-plist '(0 "eDP-1"
                                              1 "HDMI-1"
                                              2 "HDMI-1"))

      (customize-set-variable 'exwm-workspace-number
                              (if (boundp 'exwm-randr-workspace-monitor-plist)
                                  (progn
                                    (/ (safe-length exwm-randr-workspace-monitor-plist) 2))
                                1))))

      #+END_SRC

***** Enable

      #+BEGIN_SRC emacs-lisp

      (exwm-randr-enable)

      #+END_SRC

*** Security
**** Nsm

     Network Security Manager.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'nsm nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; if a potential problem with the security of the network
      ;; connection is found, the user is asked to give input
      ;; into how the connection should be handled
      ;; `high': This warns about additional things that many
      ;; people would not find useful.
      ;; `paranoid': On this level, the user is queried for
      ;; most new connections
      (customize-set-variable 'network-security-level 'paranoid)

      ;; the file the security manager settings will be stored in.
      (customize-set-variable 'nsm-setting-file
                              (expand-file-name "cache/netword-security-data" user-emacs-directory))))

      #+END_SRC

**** Tls

     This package implements a simple wrapper around "gnutls-cli" to
     make Emacs support TLS/SSL.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'tls nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; indicate if certificates should be checked against trusted root certs
      ;; if this is ‘ask’, the user can decide whether to accept an
      ;; untrusted certificate
      (customize-set-variable 'tls-checktrust t)

      ;; list of strings containing commands to
      ;; start TLS stream to a host
      ;; (customize-set-variable
      ;;  'tls-program
      ;;  '("openssl s_client -connect %h:%p -CAfile %t"))
      (customize-set-variable
       'tls-program
       '("gnutls-cli --x509cafile %t -p %p %h --insecure"))))

      #+END_SRC

**** Gnutls

     This package provides language bindings for the GnuTLS library
     using the corresponding core functions in gnutls.c

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require  'gnutls nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; if non-nil, this should be a TLS priority string
      (customize-set-variable 'gnutls-algorithm-priority nil)

      ;; if non-nil, this should be t or a list of checks
      ;; per hostname regex
      (customize-set-variable 'gnutls-verify-error nil)))

      #+END_SRC

**** Epa

     EasyPG is an all-in-one GnuPG interface for Emacs.
     It has two aspects: convenient tools which allow to use GnuPG
     from Emacs (EasyPG Assistant), and a fully
     functional interface library to GnuPG (EasyPG Library).

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'epa nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; if non-nil, cache passphrase for symmetric encryption
      (customize-set-variable
       'epa-file-cache-passphrase-for-symmetric-encryption t)

      ;; if t, always asks user to select recipients
      (customize-set-variable 'epa-file-select-keys t)

      ;; the gpg executable
      (customize-set-variable 'epg-gpg-program "gpg2")

      ;; in epa commands, a particularly useful mode is ‘loopback’, which
      ;; redirects all Pinentry queries to the caller, so Emacs can query
      ;; passphrase through the minibuffer, instead of external Pinentry
      ;; program
      (customize-set-variable 'epa-pinentry-mode 'loopback)))

      #+END_SRC

**** Auth-source

     It lets users tell Gnus how to authenticate in a single place.
     Simplicity is the goal. Instead of providing 5000 options,
     we'll stick to simple, easy to understand options.

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'auth-source nil t)

      #+END_SRC

***** Functions

      #+BEGIN_SRC emacs-lisp

      (defun eos-auth-search (host user)
        "Lookup (format HOST USER PORT) password on auth-source default file."
        (let ((auth (auth-source-search :host host :user user)))
          (if auth
              (let ((secretf (plist-get (car auth) :secret)))
                (if secretf
                    (funcall secretf)
                  (message "Auth entry for %s@%s has no secret!"
                           user host)))
            (message "No auth entry found for %s@%s" user host))))

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; Note: If the auth-sources variable contains ~/.auth.gpg before
      ;; ~/.auth, the auth-source library will try to read the GnuPG
      ;; encrypted .gpg file first, before the unencrypted file.

      ;; list of authentication sources
      (customize-set-variable
       'auth-sources '("~/.auth/auth.gpg" "~/.auth/netrc"))

      #+END_SRC

**** Password-store
***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'password-store nil t)

      #+END_SRC

**** Mml-sec
*** Session
**** Desktop
*** Packages
**** Cask

     Cask is a project management tool fo Emacs that helps
     automate the package development cycle; development,
     dependencies, testing, building, packaging and more.

     Cask can also be used to manage dependencies for your local
     Emacs configuration.

     I do prefer cask over packages.el, because the management
     of third party packages can be done outside of emacs,
     provinding more control and flexibility.

**** Packages

     The idea behind package.el is to be able to download packages
     and install them. Packages are versioned and have versioned
     dependencies.

***** Require


      #+BEGIN_SRC emacs-lisp

      (when (require 'package nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      (customize-set-variable
       'package-archives
       '(("gnu" . "https://elpa.gnu.org/packages/")
         ("melpa" . "https://melpa.org/packages/")))))

      #+END_SRC

***** Enable

      #+BEGIN_SRC emacs-lisp

      ;; enable (manually only)
      ;; (package-initialize)

      #+END_SRC

*** Process
**** Async

     Adds the ability to call asynchronous functions and process with
     ease. See the documentation for `async-start' and `async-start-process'.

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'async nil t)
      (require 'async-bytecomp nil t)

      #+END_SRC

***** Display

      #+BEGIN_SRC emacs-lisp

      ;; to run command without displaying the output in a window
      (add-to-list 'display-buffer-alist
                   '("\\*Async Shell Command\\*"
                     (display-buffer-no-window)
                     (allow-no-window . t)))

      #+END_SRC

*** Edition
**** Elec-pair

     Electric pairing: automatically matches parenthesis pairs,
     should be enabled regardless the current major mode.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'elec-pair nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; alist of pairs that should be used regardless of major mode.
      (customize-set-variable 'electric-pair-pairs
                              '((?\{ . ?\})
                                (?\( . ?\))
                                (?\[ . ?\])
                                (?\" . ?\")))

      #+END_SRC

***** Enable

      #+BEGIN_SRC emacs-lisp

      (eos-call-func 'electric-pair-mode 1)))

      #+END_SRC

**** Newcomment

     This library contains functions and variables for commenting and
     uncommenting source code.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'newcomment nil t)
        (progn

      #+END_SRC

***** Binds

      #+BEGIN_SRC emacs-lisp

      ;; global-map
      (global-set-key (kbd "M-c") 'comment-or-uncomment-region)))

      #+END_SRC

**** Delsel

     This package makes the active region be pending delete, meaning that
     text inserted while the region is active will replace the region contents.
     This is a popular behavior of personal computers text editors.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'delsel nil t)
        (progn

      #+END_SRC

***** Enable

      #+BEGIN_SRC emacs-lisp

      ;; delete selection-mode
      (eos-call-func 'delete-selection-mode 1)))

      #+END_SRC

**** Iedit

     This package includes Emacs minor modes (iedit-mode and
     iedit-rectangle-mode) based on a API library (iedit-lib) and allows you to edit
     one occurrence of some text in a buffer (possibly narrowed) or region, and
     simultaneously have other occurrences edited in the same way, with visual
     feedback as you type.

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'iedit nil t)

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; if no-nil, the key is inserted into global-map,
      ;; isearch-mode-map, esc-map and help-map.
      (customize-set-variable 'iedit-toggle-key-default t)

      #+END_SRC

***** Binds

      #+BEGIN_SRC emacs-lisp

      ;; bind (iedit-mode-keymap)
      (when (boundp 'iedit-mode-keymap)
        (progn
          (define-key iedit-mode-keymap (kbd "<tab>") 'eos/complete-buffer-or-indent)
          (define-key iedit-mode-keymap (kbd "M-n") 'iedit-next-occurrence)))

      ;; bind (global)
      ;; (global-set-key (kbd "C-;") 'iedit-mode)

      #+END_SRC

**** Undo-tree

     Emacs has a powerful undo system. Unlike the standard undo/redo system in
     most software, it allows you to recover *any* past state of a buffer
     (whereas the standard undo/redo system can lose past states as soon as you
     redo). However, this power comes at a price: many people find Emacs' undo
     system confusing and difficult to use, spawning a number of packages that
     replace it with the less powerful but more intuitive undo/redo system.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'undo-tree nil t)
        (progn

      #+END_SRC

***** Aliases

      #+BEGIN_SRC emacs-lisp

      ;; define alias for redo
      (defalias 'redo 'undo-tree-redo)

      #+END_SRC

***** Binds

      #+BEGIN_SRC emacs-lisp

      (define-key ctl-x-map (kbd "u") 'undo-tree-visualize)

      #+END_SRC

***** Enable

      #+BEGIN_SRC emacs-lisp

      ;; enable
      (eos-call-func 'global-undo-tree-mode 1)))

      #+END_SRC

**** EditorConfig

     EditorConfig helps developers define and maintain consistent
     coding styles between different editors and IDEs.

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'editorconfig nil t)

      #+END_SRC

***** Enable

      #+BEGIN_SRC emacs-lisp

      (eos-call-func 'editorconfig-mode)

      #+END_SRC

*** Buffers
**** Buffer-move

     Swap windows/buffer position (layout).

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'buffer-move nil t)
        (progn

      #+END_SRC

***** Binds

      #+BEGIN_SRC emacs-lisp

      (define-key ctl-x-map (kbd "<C-up>") 'buf-move-up)
      (define-key ctl-x-map (kbd "<C-down>") 'buf-move-down)
      (define-key ctl-x-map (kbd "<C-left>") 'buf-move-left)
      (define-key ctl-x-map (kbd "<C-right>")'buf-move-right)))

      #+END_SRC

*** Graphics
**** Artist

     Artist is an Emacs lisp package that allows you to draw lines,
     rectangles and ellipses by using your mouse and/or keyboard.  The
     shapes are made up with the ascii characters |, -, / and \.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'artist nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; whether or not to incrementally update display when flood-filling
      (customize-set-variable 'artist-flood-fill-show-incrementally nil)

      ;; whether or not to remove white-space at end of lines
      (customize-set-variable 'artist-trim-line-endings nil)))

      #+END_SRC

*** Readers
**** Elfeed

     Elfeed is a web feed client for Emacs, inspired by notmuch.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'elfeed nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; directory where elfeed will store its database.
      (customize-set-variable
       'elfeed-db-directory
       (concat (expand-file-name user-emacs-directory) "elfeed"))

      ;; default directory for saving enclosures. Hide
      (customize-set-variable
       'elfeed-enclosure-default-dir
       (concat (expand-file-name user-emacs-directory) "cache/elfeed"))))

      #+END_SRC

*** Files
**** Dired

     This is a major mode for directory
     browsing and editing.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'dired nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; enable dired-find-alternate-file
      (put 'dired-find-alternate-file 'disabled nil)))

      #+END_SRC

**** Dired-async

     This package provides a redefinition of `dired-create-file' function,
     performs copies, moves and all what is handled by `dired-create-file'
     in the background using a slave Emacs process, by means of
     the async.el module.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'dired-async nil t)
        (progn

      #+END_SRC

***** Enable

      #+BEGIN_SRC emacs-lisp

      (eos-call-func 'dired-async-mode 1)

      #+END_SRC

***** Binds

      #+BEGIN_SRC emacs-lisp

      (if (boundp 'dired-mode-map)
          (progn
            (define-key dired-mode-map (kbd "RET") 'dired-find-alternate-file)
            (define-key dired-mode-map (kbd "C-j") 'dired-find-alternate-file)))))

      #+END_SRC

**** Dired-subtree

     This package defines function `dired-subtree-insert' which instead
     inserts the subdirectory directly below its line in the original
     listing, and indent the listing of subdirectory to resemble a
     tree-like structure (somewhat similar to tree(1) except the pretty
     graphics).

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'dired-subtree nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; default depth expanded by `dired-subtree-cycle'
      (customize-set-variable 'dired-subtree-cycle-depth 2)

      ;; a prefix put into each nested subtree
      (customize-set-variable 'dired-subtree-line-prefix "  ")

      ;; specifies how the prefix is fontified, subtree
      (customize-set-variable 'dired-subtree-line-prefix-face 'subtree)

      ;; when non-nil, add a background face to a subtree listing.
      (customize-set-variable 'dired-subtree-use-backgrounds nil)

      #+END_SRC

***** Binds

      #+BEGIN_SRC emacs-lisp

      (when (boundp 'dired-mode-map)
        (progn
          (define-key dired-mode-map (kbd "TAB") 'dired-subtree-insert)
          (define-key dired-mode-map (kbd "<M-tab>") 'dired-subtree-remove)))))

      #+END_SRC

*** News

    - News: This is what you are supposed to use this thing for—reading news.
      News is generally fetched from a nearby NNTP server, and is
      generally publicly available to everybody.

      - Mail: Everything that’s delivered to you personally is mail. Some
      news/mail readers (like Gnus) blur the distinction between mail
      and news, but there is a difference.
      Mail is private. News is public.
      Mailing is not posting, and replying is not following up.

      - Reply: Send a mail to the person who has written what you are
        reading.

**** Gnus

     The Gnus Newsreader:

     You can read news (and mail) from within Emacs by using Gnus. The news
     can be gotten by any nefarious means you can think of—NNTP, local spool
     or your mbox file.  All at the same time, if you want to push
     your luck.

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'gnus nil t)

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; default method for selecting a newsgroup
      ;; nnnil is a Gnus backend that provides no groups or articles.  It's useful
      ;; as a primary select method when you want all your real select methods to
      ;; be secondary or foreign.
      (customize-set-variable 'gnus-select-method '(nnnil))

      ;; a list of secondary methods that will be used for reading news
      (customize-set-variable
       'gnus-secondary-select-methods '((nntp "news.gwene.org")
                                        (nnimap "gmail"
                                                (nnimap-address "imap.gmail.com")
                                                (nnimap-stream ssl)
                                                (nnimap-server-port "imaps")
                                                (nnimap-fetch-partial-articles t)
                                                (nnimap-authinfo-file "~/.auth/auth.gpg"))))

      ;; if non-nil, automatically mark Gcc articles as read
      (customize-set-variable 'gnus-gcc-mark-as-read nil)

      ;; whether we want to use the Gnus agent or not
      (customize-set-variable 'gnus-agent t)

      ;; non-nil means that you are a usenet novice
      (customize-set-variable 'gnus-novice-user t)

      ;; non-nil means that Gnus will run `gnus-find-new-newsgroups' at startup
      (customize-set-variable 'gnus-check-new-newsgroups 'ask-server)

      ;; non-nil means that Gnus will read the entire active file at startup
      (customize-set-variable 'gnus-read-active-file 'some)

      ;; if non-nil, use the entire emacs screen
      (customize-set-variable 'gnus-use-full-window nil)

      #+END_SRC

**** Nnmail

     Mail support functions for the Gnus mail backends.

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'nnmail nil t)

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; expirable articles that are older than this will be expired
      (customize-set-variable 'nnmail-expiry-wait 30)

      #+END_SRC

*** Mail
**** Messages

     This mode provides mail-sending facilities from within Emacs.  It
     consists mainly of large chunks of code from the sendmail.el,
     gnus-msg.el and rnewspost.el files.

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'message nil t)

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; your preference for a mail composition package
      (customize-set-variable 'mail-user-agent 'message-user-agent)

      ;; if non-nil, `compose-mail' warns about changes in `mail-user-agent'
      (customize-set-variable 'compose-mail-user-agent-warnings nil)

      ;; if it is nil, use Gnus; else use `mail-user-agent'
      (customize-set-variable 'message-mail-user-agent t)

      ;; string to be inserted at the end of the message buffer
      (customize-set-variable 'message-signature "")

      ;; format of the "Whomever writes:" line
      (customize-set-variable 'message-citation-line-format "%f [%Y-%m-%d, %R %z]:\n")

      ;; function called to insert the "Whomever writes:" line
      (customize-set-variable 'message-citation-line-function
                              'message-insert-formatted-citation-line)
      ;; function that inserts a formatted citation line

      ;; when non-nil, ask for confirmation when sending a message
      (customize-set-variable 'message-confirm-send t)

      ;; non-nil means that the message buffer will be killed after sending a message
      (customize-set-variable 'message-kill-buffer-on-exit t)

      ;; whether to confirm a wide reply to multiple email recipients
      (customize-set-variable 'message-wide-reply-confirm-recipients t)

      ;; this variable is obsolete since 26.1;
      ;; the default charset comes from the language environment
      ;; default charset used in non-MULE Emacsen
      (customize-set-variable 'message-default-charset 'utf-8)

      #+END_SRC

***** Functions

      #+BEGIN_SRC emacs-lisp

      (defun eos/message-header-add-gcc ()
        "While `gnus' is running, add a Gcc header, if missing.
      The Gcc header places a copy of the outgoing message to the
      appropriate directory of the IMAP server, as per the contents of
      `auth-sources'.
      In the absence of a Gcc header, the outgoing message will not
      appear in the appropriate IMAP directory, though it will still be
      sent. Add this function to `message-header-setup-hook'."
        (if (gnus-alive-p)
            (progn
              (when (message-fetch-field "Gcc")
                (message-remove-header "Gcc")
                (message-add-header "Gcc: nnimap+pub:Sent")))
          (message "Gnus is not running. No GCC field inserted.")))

      #+END_SRC

***** Hooks

      #+BEGIN_SRC emacs-lisp

      ;; hook called narrowed to the headers when setting up a message buffer
      (add-hook 'message-header-setup-hook #'eos/message-header-add-gcc)

      ;; normal hook, run each time a new outgoing message is initialized
      (add-hook 'message-setup-hook #'message-sort-headers)

      #+END_SRC

**** Sendmail

     This mode provides mail-sending facilities from within Emacs.
     It is documented in the Emacs user's manual.

***** Require

      #+BEGIN_SRC emacs-lisp

      ;; (require 'sendmail nil t)

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; text inserted at end of mail buffer when a message is initialized
      ;; (customize-set-variable 'mail-signature "")

      #+END_SRC

*** Bar
**** Moody

     This package provides utilities for displaying elements of the
     mode line as tabs and ribbons.  It also provides replacements
     for a few built-in elements.

     Emacs has to be compiled with xpm support, for this package
     to work properly.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'moody nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; remove underline
      (customize-set-variable 'x-underline-at-descent-line t)

      ;; change line height
      (customize-set-variable 'moody-mode-line-height 1)

      ;; mode-line format
      (customize-set-variable 'mode-line-format
                              '("%e"
                                ;; "%*%& %l:%c | %I "
                                " "
                                mode-line-mule-info
                                mode-line-modified
                                ;; " %*%& "
                                ;; mode-line-misc-info
                                ;; mode-line-percent-position
                                " %l:%c "
                                ;; mode-line-misc-info
                                moody-mode-line-buffer-identification
                                ""
                                " %m "
                                (vc-mode moody-vc-mode)
                                " "
                                ))))

      #+END_SRC

*** Chat
**** Rcirc

     Internet Relay Chat (IRC) is a form of instant communication over
     the Internet. It is mainly designed for group (many-to-many)
     communication in discussion forums called channels, but also allows
     one-to-one communication.

     Rcirc has simple defaults and clear and consistent behavior.
     Message arrival timestamps, activity notification on the mode line,
     message filling, nick completion, and keepalive pings are all
     enabled by default, but can easily be adjusted or turned off.  Each
     discussion takes place in its own buffer and there is a single
     server buffer per connection.

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'rcirc nil t)

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; non-nil means log IRC activity to disk
      ;; logfiles are kept in `rcirc-log-directory
      (customize-set-variable 'rcirc-log-flag nil)

      ;; major-mode function to use in multiline edit buffers
      (customize-set-variable 'rcirc-multiline-major-mode 'text-mode)

      ;; format string to use in nick completions
      (customize-set-variable 'rcirc-completion-fomart "%s:")

      ;; list of authentication passwords (not your job)
      (customize-set-variable 'rcirc-authinfo nil)

      ;; coding system used to decode incoming irc messages
      (customize-set-variable 'rcirc-decode-coding-system 'utf-8)

      ;; responses which will be hidden when `rcirc-omit-mode is enable
      (customize-set-variable 'rcirc-omit-responses
                              '("JOIN" "PART" "QUIT" "NICK"))

      #+END_SRC

***** Functions

      #+BEGIN_SRC emacs-lisp


      #+END_SRC

***** Hooks
***** Binds
***** Enable

      #+BEGIN_SRC emacs-lisp

      ;; (rcirc-omit-mode 1)))

      #+END_SRC

**** Jabber
**** Slack
*** Shell
**** Shell

     This package defines a shell-in-a-buffer (shell mode) built on
     top of comint mode.  This is actually cmushell with things renamed
     to replace its counterpart in Emacs 18.  cmushell is more
     featureful, robust, and uniform than the Emacs 18 version.

     Since this mode is built on top of the general command-interpreter-in-
     a-buffer mode (comint mode), it shares a common base functionality,
     and a common set of bindings, with all modes derived from comint mode.
     This makes these modes easier to use.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'shell nil t)
        (progn

      #+END_SRC

***** Hooks

      #+BEGIN_SRC emacs-lisp

      ;; hook
      (add-hook 'shell-mode-hook
                (lambda()
                  ;; do not display continuation lines.
                  (setq truncate-lines nil)))))

      #+END_SRC

**** Eshell

     Despite the sheer fact that running an Emacs shell can be fun, here
     are a few of the unique features offered by Eshell:

     - Integration with the Emacs Lisp programming environment
     - A high degree of configurability.

     - The ability to have the same shell on every system Emacs has been
       ported to. Since Eshell imposes no external requirements, and
       relies upon only the Lisp functions exposed by Emacs, it is quite
       operating system independent. Several of the common UNIX
       commands, such as ls, mv, rm, ln, etc., have been implemented in
       Lisp in order to provide a more consistent work environment.

       - If there is a command on disk, it will be executed
         as in a normal shell.  If there is no command by that name on disk,
         but a Lisp function with that name is defined, the Lisp function
         will be called, using the arguments passed on the command line.

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'eshell nil t)

      #+END_SRC

***** Binds

      #+BEGIN_SRC emacs-lisp

      ;; ctl-x-map (C-x)
      (define-key ctl-x-map (kbd "&") 'eshell)

      #+END_SRC

*** Terminal
**** Term

     Command-interpreter-in-a-buffer package (term mode).
     The idea is that you can build specific process-in-a-buffer
     modes on top of term mode -- e.g., lisp, shell, scheme, T, soar, ...

     It seems that ~sh~ shell works better with term.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'term nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; if non-nil, is file name to use for explicitly
      ;; requested inferior shell
      (customize-set-variable
       'explicit-shell-file-name (getenv "SHELL"))

      ;; if non-nil, add a ‘/’ to completed directories
      (customize-set-variable 'term-completion-addsuffix t)

      ;; regexp to recognize prompts in the inferior process
      ;; (customize-set-variable 'term-prompt-regexp "^\\(>\\|\\(->\\)+\\) *")
      ;; (customize-set-variable 'term-prompt-regexp ".*:.*>.*? ")

      ;; if non-nil, automatically list possibilities on partial completion.
      (customize-set-variable 'term-completion-autolist t)

      ;; if true, buffer name equals process name
      (customize-set-variable 'term-ansi-buffer-base-name t)

      #+END_SRC

***** Functions

      #+BEGIN_SRC emacs-lisp

      ;; functions
      (defun eos/term-send-kill-line ()
        "Kill line in multi-term mode with the possibility to paste it like in a normal shell."
        (interactive)
        (when (fboundp 'term-send-raw-string)
          (progn
            (kill-line)
            (term-send-raw-string "\C-k"))))

      #+END_SRC

***** Binds

      #+BEGIN_SRC emacs-lisp

      ;; bind term-raw-map/term-mode-map with hook
      (add-hook 'term-mode-hook
                (lambda ()
                  (when (and (boundp 'term-raw-map)
                             (boundp 'term-mode-map))
                    (progn
                      ;; term-raw-map
                      (define-key term-raw-map (kbd "s-q") 'term-line-mode)

                      ;; term-mode-map
                      (define-key term-mode-map (kbd "s-q") 'term-char-mode)))))

      #+END_SRC

***** Hooks

      #+BEGIN_SRC emacs-lisp

      ;; do not display continuation lines.
      (add-hook 'term-mode-hook
                (lambda()
                  (setq truncate-lines nil)))))

      #+END_SRC

**** Multi-term

     This package is for creating and managing multiple
     terminal buffers in Emacs.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'multi-term nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; if this is nil, setup to environment variable of `SHELL'"
      (customize-set-variable 'multi-term-program nil)

      ;; focus terminal window after you open dedicated window
      (customize-set-variable 'multi-term-dedicated-select-after-open-p t)

      ;; the buffer name of term buffer.
      (customize-set-variable 'multi-term-buffer-name "Term")

      #+END_SRC

***** Binds

      #+BEGIN_SRC emacs-lisp

      ;; clt-x-map (C-x) prefix
      (define-key ctl-x-map (kbd "<C-return>") 'multi-term)
      (define-key ctl-x-map (kbd "<return>") 'multi-term-dedicated-toggle)))

      #+END_SRC

*** Browser
**** Shr

     This package takes a HTML parse tree (as provided by
     libxml-parse-html-region) and renders it in the current buffer.  It
     does not do CSS, JavaScript or anything advanced: It's geared
     towards rendering typical short snippets of HTML, like what you'd
     find in HTML email and the like.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'shr nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; frame width to use for rendering
      (customize-set-variable 'shr-width 120)

      ;; if non-nil, use proportional fonts for text
      (customize-set-variable 'shr-use-fonts nil)

      ;; if non-nil, respect color specifications in the HTML
      (customize-set-variable 'shr-use-colors nil)

      ;; if non-nil, inhibit loading images
      (customize-set-variable 'shr-inhibit-images nil)

      ;; images that have URLs matching this regexp will be blocked (regexp)
      (customize-set-variable 'shr-blocked-images nil)))

      #+END_SRC

**** Eww

     Elisp www browser configuration.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'eww nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; prefix uRL to search engine
      (customize-set-variable 'eww-search-prefix "https://www.google.com/search?q=")
      ;; (customize-set-variable eww-search-prefix "https://duckduckgo.com/html/?q=")

      ;; directory where files will downloaded
      (customize-set-variable 'eww-download-directory "~/down")

      ;; symbol used to represent a checkbox
      (customize-set-variable 'eww-form-checkbox-symbol "[ ]")

      ;; symbol used to represent a selected checkbox.
      (customize-set-variable 'eww-form-checkbox-selected-symbol "[X]")
      ;; (customize-set-variable eww-form-checkbox-symbol "☐") ; Unicode hex 2610
      ;; (customize-set-variable eww-form-checkbox-selected-symbol "☑") ; Unicode hex 2611

      #+END_SRC

***** Hooks

      #+BEGIN_SRC emacs-lisp

      (add-hook 'eww-mode-hook
                (lambda ()
                  ;; disable truncate lines
                  (setq truncate-lines nil)))))

      #+END_SRC

***** Binds

      #+BEGIN_SRC emacs-lisp

      (when (boundp 'eww-mode-map)
        (progn
          (define-key eww-mode-map (kbd "C-j") 'eww-follow-link)))

      #+END_SRC

**** Browse-url

     This package provides functions which read a URL (Uniform Resource
     Locator) from the minibuffer, defaulting to the URL around point,
     and ask a World-Wide Web browser to load it.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'browse-url nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; the name of the browser program used by ‘browse-url-generic’.
      (customize-set-variable 'browse-url-generic-program "eww")

      ;; function to display the current buffer in a WWW browser: eww
      (customize-set-variable 'browse-url-browser-function 'eww-browse-url)))

      #+END_SRC

*** Filters
**** Grep
**** Rg
**** Ripgrep
*** Checkers
**** Ispell

     Aspell is a utility program that connects to the Aspell library so that
     it can function as an ispell -a replacement, as an independent spell
     checker, as a test utility to test out Aspell library features, and as
     a utility for managing dictionaries used by the library.

     Note : Ispell minor mode configuration requires aspell program.
     TIP  : On FreeBSD: pkg info aspell

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'ispell nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; program invoked by M-x ispell-word and M-x ispell-region commands.
      (customize-set-variable 'ispell-program-name "aspell")

      #+END_SRC

***** Display

      #+BEGIN_SRC emacs-lisp

      ;; (add-to-list 'display-buffer-alist
      ;;              '("\\*Choices\\*"
      ;;                (display-buffer-below-selected display-buffer-at-bottom)
      ;;                (inhibit-same-window . t)
      ;;                (window-height . 0.2)))

      #+END_SRC

***** Functions

      #+BEGIN_SRC emacs-lisp

      ;; silent compiler
      (defvar ispell-current-dictionary nil nil)

      (defun eos/ispell/switch-dictionary ()
        "Switch dictionaries."
        (interactive)
        (let* ((dic ispell-current-dictionary)
               (change (if (string= dic "english") "brasileiro" "english")))
          (ispell-change-dictionary change)
          (message "Dictionary switched from %s to %s" dic change)))

      #+END_SRC

***** Enable

      #+BEGIN_SRC emacs-lisp

      ;; enable globally
      (ispell-minor-mode 1)

      #+END_SRC

***** Binds

      #+BEGIN_SRC emacs-lisp

      ;; eos-sc-map
      (define-key eos-sc-map (kbd "i") 'ispell-word)
      (define-key eos-sc-map (kbd "I") 'ispell-buffer)))

      #+END_SRC

**** Flyspell

     Flyspell is a minor Emacs mode performing on-the-fly spelling
     checking.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'flyspell nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; string that is the name of the default dictionary
      (customize-set-variable 'flyspell-default-dictionary "english")

      #+END_SRC

***** Hooks

      #+BEGIN_SRC emacs-lisp

      ;; hooks
      (add-hook 'text-mode-hook #'flyspell-mode)
      (add-hook 'prog-mode-hook #'flyspell-prog-mode)))

      #+END_SRC

**** Flycheck

     Flycheck is a modern on-the-fly syntax checking extension.

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'flycheck nil t)

      #+END_SRC

***** Functions

      #+BEGIN_SRC emacs-lisp

      (defun eos/set-flycheck-checker (checker)
        "Set flycheck CHECKER variable."
        (make-local-variable 'flycheck-checker)
        (when (boundp 'flycheck-checker)
          (setq flycheck-checker checker)))

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      #+END_SRC

***** Display

      #+BEGIN_SRC emacs-lisp

     ;; dont display this buffer
     (add-to-list 'display-buffer-alist
                  '("\\*Flycheck error messages\\*"
                    (display-buffer-no-window)
                    (allow-no-window . t)))

      #+END_SRC

***** Hooks

      #+BEGIN_SRC emacs-lisp

      ;; init flycheck mode after some programming mode
      ;; is activated (c-mode, elisp-mode, etc).
      (add-hook 'prog-mode-hook
                (lambda ()
                  (interactive)
                  (flycheck-mode 1)))

      #+END_SRC

***** Enable

      #+BEGIN_SRC emacs-lisp

      ;; (global-flycheck-mode 1)

      #+END_SRC

***** Binds

      #+BEGIN_SRC emacs-lisp

      ;; binds
      (define-key eos-sc-map (kbd "C-g") 'keyboard-quit)
      (define-key eos-sc-map (kbd "e") 'flycheck-list-errors)
      (define-key eos-sc-map (kbd "b") 'flycheck-buffer)
      (define-key eos-sc-map (kbd "d") 'flycheck-disable-checker)
      (define-key eos-sc-map (kbd "m") 'flycheck-mode)
      (define-key eos-sc-map (kbd "s") 'flycheck-select-checker)
      (define-key eos-sc-map (kbd "?") 'flycheck-describe-checker)

      ;; (define-key eos-sc-map (kbd "M") 'flycheck-manual)
      ;; (define-key eos-sc-map (kbd "v") 'flycheck-verify-setup)

      #+END_SRC

*** Launcher
**** Dmenu

     Dmenu is a fast and lightweight dynamic menu for X.
     It reads arbitrary text from stdin, and creates a
     menu with one item for each line. The user can then select an item,
     through the arrow keys or typing a part of the name,
     and the line is printed to stdout.

     Dmenu_run is a wrapper that ships with the dmenu
     distribution that allows its use as an application launcher.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'dmenu nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; string to display in the dmenu prompt
      (customize-set-variable 'dmenu-prompt-string "Dmenu: ")

      ;; determines on how many recently executed commands
      ;; dmenu should keep a record
      (customize-set-variable 'dmenu-history-size 8)

      ;; file in which the dmenu state is
      ;; saved between Emacs sessions
      (customize-set-variable
       'dmenu-save-file
       (expand-file-name "cache/dmenu-items" user-emacs-directory))

      #+END_SRC

***** Binds

      #+BEGIN_SRC emacs-lisp

      ;; clt-x-map (C-x) prefix
      (define-key ctl-x-map (kbd "C-l") 'dmenu)))

      #+END_SRC

*** Interpreters

    Generic interpreter interface configurations and customization,
    languages specific interpreters (for example: python)
    will be placed in the ~Programming~ sections.

**** Comint

     This package defines a general command-interpreter-in-a-buffer
     (comint mode). The idea is that you can build specific process-in-a-buffer
     modes on top of comint mode -- e.g., Lisp, shell, scheme, T, soar, ....

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'comint nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; if non-nil, assume that the subprocess echoes any input.
      (customize-set-variable 'comint-process-echoes t)

      ;; if non-nil, use comint-prompt-regexp to recognize prompts.
      (customize-set-variable 'comint-use-prompt-regexp t)

      ;; regexp to recognize prompts in the inferior process.
      ;; (customize-set-variable 'comint-prompt-regexp ".*:.*>.*? ")

      ;; value to use for TERM when the system uses terminfo.
      (customize-set-variable 'comint-terminfo-terminal "eterm-color")))

      #+END_SRC

**** IELM
***** Require

      Provides a nice interface to evaluating Emacs Lisp expressions.
      Input is handled by the comint package, and output is passed
      through the pretty-printer.

      #+BEGIN_SRC emacs-lisp

      (when (require 'ielm nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; if non-nil, after entering the first line of
      ;; an incomplete sexp, a newline will be inserted after the prompt.
      (customize-set-variable 'ielm-dynamic-multiline-inputs t)

      ;; if non-nil, IELM will beep on error
      (customize-set-variable 'ielm-noisy nil)

      ;; prompt used in IELM
      (customize-set-variable 'ielm-prompt "elisp > ")

      ;; if non-nil, the IELM prompt is read only
      (customize-set-variable 'ielm-prompt-read-only nil)))

      #+END_SRC

**** Sql

     Specialized ~comint.el~ for SQL interpreters.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'sql nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; select the SQL database product used
      (customize-set-variable 'sql-product "sqlite")))

      #+END_SRC

*** Comparators
**** Diff

     This package helps you explore differences between files, using the
     UNIX command diff(1). The commands are `diff' and `diff-backup'.
     You can specify options with `diff-switches'.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'diff nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; a string or list of strings specifying switches to be passed to diff
      (customize-set-variable 'diff-switches "-u")))

      #+END_SRC

**** Ediff

     This package provides a convenient way of simultaneous browsing through
     the differences between a pair (or a triple) of files or buffers.
     The files being compared, file-A, file-B, and file-C (if applicable) are
     shown in separate windows (side by side, one above the another, or in
     separate frames), and the differences are highlighted as you step
     through them.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'ediff nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; options to pass to `ediff-custom-diff-program'.
      (customize-set-variable 'ediff-custom-diff-options "-U3")

      ;; the function used to split the main window between buffer-A and buffer-B
      (customize-set-variable 'ediff-split-window-function 'split-window-horizontally)

      ;; function called to set up windows
      (customize-set-variable 'ediff-window-setup-function 'ediff-setup-windows-plain)

      #+END_SRC

***** Hooks

      #+BEGIN_SRC emacs-lisp

      (add-hook 'ediff-startup-hook 'ediff-toggle-wide-display)
      (add-hook 'ediff-cleanup-hook 'ediff-toggle-wide-display)
      (add-hook 'ediff-suspend-hook 'ediff-toggle-wide-display)))

      #+END_SRC

*** Compositor
**** Compton

     Compton is a compositor based on Dana Jansens' version of xcompmgr
     (which itself was written by Keith Packard). It includes some
     improvements over the original xcompmgr, like window frame opacity and
     inactive window transparency.

     Start compton after emacs initialize.

***** Functions

      #+BEGIN_SRC emacs-lisp

      (defun eos/compton ()
        "Call compton compositor utility."
        (interactive)
        (eos-call-proc "compton" "-b"))

      #+END_SRC

***** Hooks

      #+BEGIN_SRC emacs-lisp

      ;; start compton after emacs initialize
      (add-hook 'after-init-hook #'eos/compton)

      #+END_SRC

*** Calculators
**** Calc
*** Clients
**** Verb

     Verb is a package that allows you to organize and send HTTP
     requests from Emacs.  See the project's README.md file for more
     details.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'verb nil t)
        (progn

      #+END_SRC

***** Hooks

      #+BEGIN_SRC emacs-lisp

      (add-hook 'org-ctrl-c-ctrl-c-hook
                (lambda ()
                  (when (boundp 'verb-mode)
                    (if verb-mode
                        (eos-call-func 'verb-send-request-on-point 'this-window)))))))

      #+END_SRC

**** Tramp

     TRAMP is for transparently accessing remote files from within Emacs.
     TRAMP enables an easy, convenient, and consistent interface to remote
     files as if they are local files.  TRAMP’s transparency extends to
     editing, version control, and dired.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'tramp nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; set tramp default method
      (customize-set-variable 'tramp-default-method "ssh")

      ;; if non-nil, chunksize for sending input to local process.
      ;; (customize-set-variable 'tramp-chunksize 512)

      ;; a value of t would require an immediate reread during filename completion,
      ;; nil means to use always cached values for the directory contents.
      (customize-set-variable 'tramp-completion-reread-directory-timeout nil)

      ;; set tramp verbose level
      (customize-set-variable 'tramp-verbose 4)

      ;; file which keeps connection history for tramp connections.
      (customize-set-variable
       'tramp-persistency-file-name
       (concat (expand-file-name user-emacs-directory) "cache/tramp"))

      ;; connection timeout in seconds
      (customize-set-variable 'tramp-connection-timeout 60)))

      #+END_SRC

**** Mentor
*** Controllers
**** Slock
***** Functions

      #+BEGIN_SRC emacs-lisp

      (defun eos/slock ()
        "Call slock utility."
        (interactive)
        (eos-call-proc "slock" nil))

      #+END_SRC

***** Binds

      #+BEGIN_SRC emacs-lisp

      (define-key ctl-x-map (kbd "<end>") 'eos/slock)

      #+END_SRC

**** Scrot
***** Functions

      #+BEGIN_SRC emacs-lisp

      (defun eos/scrot ()
        "Call scrot utility."
        (interactive)
        (message "Saved in %s directory" (pwd))
        (eos-call-proc "scrot" nil))

      #+END_SRC

***** Binds

      #+BEGIN_SRC emacs-lisp

      ;; global-map
      (global-set-key (kbd "<print>") 'eos/scrot)

      #+END_SRC

**** Volume
***** Functions

      #+BEGIN_SRC emacs-lisp

      (defun eos/raise-volume ()
        "Raise volume by a factor of 5."
        (interactive)
        (async-shell-command "amixer -D default set Master 5+ unmute"))

      (defun eos/reduce-volume ()
        "Reduce volume by a factor of -5."
        (interactive)
        (async-shell-command "amixer -D default set Master 5- unmute"))

      (defun eos/toggle-audio ()
        "Toggle audio mute/unmute."
        (interactive)
        (async-shell-command "amixer -D default set Master"))

      #+END_SRC

***** Binds

      #+BEGIN_SRC emacs-lisp

      ;; global-map
      (global-set-key (kbd "s-0") 'eos/toggle-audio)
      (global-set-key (kbd "s--") 'eos/reduce-volume)
      (global-set-key (kbd "s-=") 'eos/raise-volume)

      #+END_SRC

*** Calendar
*** Dashboards
**** Dashboard

     An extensible Emacs dashboard, with sections for
     bookmarks, projectile projects, org-agenda and more.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'dashboard nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; association list of items to show in the startup buffer.
      (customize-set-variable 'dashboard-items
                              '((recents . 4)
                                (projects . 4)
                                (agenda . 4)
                                (bookmarks . 4)))

      ;; banners directory
      (customize-set-variable 'dashboard-banners-directory
                              (concat user-emacs-directory "banner/"))

      ;; specify the startup banner
      (customize-set-variable 'dashboard-startup-banner 1)

      ;; separator to use between the different pages.
      (customize-set-variable 'dashboard-page-separator "

      ")

      ;; footer icon
      (customize-set-variable 'dashboard-footer-icon
                              #(" " 0 1 (face dashboard-footer)))

      ;; a footer with some short message
      (customize-set-variable 'dashboard-footer
                              "Litany Against Fear

       I must not fear.
       Fear is the mind-killer.
       Fear is the little-death that brings total obliteration.
       I will face my fear.
       I will permit it to pass over me and through me.
       And when it has gone past I will turn the inner eye to see its path.
       Where the fear has gone there will be nothing.
       Only I will remain.
       ")

      ;; when non nil, a footer will be displayed at the bottom.
      (customize-set-variable 'dashboard-set-footer t)

      ;; a list of messages, one of which dashboard chooses to display
      (customize-set-variable 'dashboard-footer-messages nil)

      ;; when non nil, file lists will have icons
      (customize-set-variable 'dashboard-set-file-icons t)

      ;; when non nil, heading sections will have icons
      (customize-set-variable 'dashboard-set-heading-icons nil)

      ;; set initial buffer choice (emacsclient fix)
      (customize-set-variable 'initial-buffer-choice
                              (lambda ()
                                (let ((initial-buffer (get-buffer "*dashboard*")))
                                  (unless initial-buffer
                                    (setq initial-buffer (get-buffer "*scratch*")))
                                  initial-buffer)))

      #+END_SRC

***** Hooks

      #+BEGIN_SRC emacs-lisp

      ;; init dashboard after emacs initialize
      (add-hook 'after-init-hook 'dashboard-setup-startup-hook)))

      #+END_SRC

*** Multimedia
**** Emms

     Emms is the Emacs Multi-Media System. It tries to be a clean and small
     application to play multimedia files from Emacs using external
     players. The basic functionality of Emms consists of three parts:
     The core, the sources, and the players.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (and (require 'emms nil t)
                 (require 'emms-setup nil t))
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; list of players that emms can use (only mpv)
      (customize-set-variable 'emms-player-list '(emms-player-mpv))

      ;; the default directory to look for media files.
      (customize-set-variable
       'emms-source-file-default-directory (expand-file-name "~/media"))

      #+END_SRC

***** Hooks

      #+BEGIN_SRC emacs-lisp

      ;; disable emms mode line
      (add-hook 'emms-playlist-mode-hook
                (lambda ()
                  (when (and (boundp 'emms-mode-line-active-p)
                             (fboundp 'emms-mode-line-disable))
                    (progn
                      (if emms-mode-line-active-p
                          (emms-mode-line-disable))))))))

      #+END_SRC

***** Enable

      #+BEGIN_SRC emacs-lisp

      ;; if emms is available, enable it
      (when (and (fboundp 'emms-all)
                 (fboundp 'emms-default-players))
        (progn
          (funcall 'emms-all)
          (funcall 'emms-default-players)))

      #+END_SRC

*** Icons
**** All-the-icons

     This package is a utility for using and formatting various Icon
     fonts within Emacs.  Icon Fonts allow you to propertize and format
     icons the same way you would normal text. This enables things such
     as better scaling of and anti aliasing of the icons.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'all-the-icons nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; whether or not to include a foreground colour when formatting the icon
      (customize-set-variable 'all-the-icons-color-icons nil)

      ;; the default adjustment to be made to the `raise' display property of an icon
      (customize-set-variable 'all-the-icons-default-adjust -0.0)

      ;; the base Scale Factor for the `height' face property of an icon
      (customize-set-variable 'all-the-icons-scale-factor 1.0)))

      #+END_SRC

*** Office
**** Remember
**** Org

     Org is a mode for keeping notes, maintaining ToDo lists, and doing
     project planning with a fast and effective plain-text system.

     Org mode develops organizational tasks around NOTES files that
     contain information about projects as plain text.  Org mode is
     implemented on top of outline-mode, which makes it possible to keep
     the content of large files well structured.  Visibility cycling and
     structure editing help to work with the tree.  Tables are easily
     created with a built-in table editor.  Org mode supports ToDo
     items, deadlines, time stamps, and scheduling.  It dynamically
     compiles entries into an agenda that utilizes and smoothly
     integrates much of the Emacs calendar and diary.  Plain text
     URL-like links connect to websites, emails, Usenet messages, BBDB
     entries, and any files related to the projects.  For printing and
     sharing of notes, an Org file can be exported as a structured ASCII
     file, as HTML, or (todo and agenda items only) as an iCalendar
     file. It can also serve as a publishing tool for a set of linked
     webpages.

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'org nil t)

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; custom
      ;; when non-nil, fontify code in code blocks
      (customize-set-variable 'org-src-fontify-natively t)

      ;; if non-nil, the effect of TAB in a code block is as if it were
      ;; issued in the language major mode buffer
      (customize-set-variable 'org-src-tab-acts-natively t)

      ;; indentation for the content of a source code block.
      (customize-set-variable 'org-edit-src-content-indentation 0)

      ;; confirm before evaluation
      (customize-set-variable 'org-confirm-babel-evaluate nil)

      ;; how the source code edit buffer should be displayed
      (customize-set-variable 'org-src-window-setup 'current-window)

      ;; non-nil means C-a and C-e behave specially in headlines and items
      (customize-set-variable 'org-special-ctrl-a/e t)

      ;; languages which can be evaluated in Org buffers.
      (customize-set-variable 'org-babel-load-languages
                              '((emacs-lisp . t)
                                (python . t)))

      #+END_SRC

***** Functions

      #+BEGIN_SRC emacs-lisp

      (defun eos/build ()
        "If the current buffer is 'init.org' the code-blocks are tangled.
      The tangled file will be compiled."
        (interactive)

        ;; avoid running hooks when tangling.
        (let ((prog-mode-hook nil)
              (buffer (current-buffer)))

          ;; switch or open init.org file
          (find-file (expand-file-name "init.org" user-emacs-directory))

          ;; tangle and compile
          (org-babel-tangle)
          (byte-compile-file (concat user-emacs-directory "init.el"))

          ;; switch to the previous buffer
          (switch-to-buffer buffer)))

      #+END_SRC

***** Hooks

      #+BEGIN_SRC emacs-lisp

      (add-hook 'org-mode-hook
                (lambda ()
                  ;; do not truncate lines
                  (setq truncate-lines nil)

                  ;; set company backends
                  (eos-set-company-backends
                   '((company-ispell
                      company-yasnippet
                      company-dabbrev
                      company-dabbrev-code)
                     (company-files)))))

      #+END_SRC

***** Binds

      #+BEGIN_SRC emacs-lisp

      ;; silent compiler
      (defvar org-mode-map nil nil)

      (define-key org-mode-map (kbd "C-M-i") 'eos/complete-buffer-or-indent)

      #+END_SRC

**** Org-Agenda
**** Tex

     Major mode for editing files of input for TeX, LaTeX, or SliTeX.
     Tries to determine (by looking at the beginning of the file) whether
     this file is for plain TeX, LaTeX, or SliTeX and calls plain-tex-mode,
     latex-mode, or slitex-mode, respectively.  If it cannot be determined,
     such as if there are no commands in the file, the value of ‘tex-default-mode’
     says which mode to use.

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'tex-mode nil t)

      #+END_SRC

**** Text

     This package provides the fundamental text mode documented in the
     Emacs user's manual.

     Major mode for editing text written for humans to read.
     In this mode, paragraphs are delimited only by blank or white lines.
     You can thus get the full benefit of adaptive filling
     (see the variable `adaptive-fill-mode').

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'text-mode nil t)
        (progn

      #+END_SRC

***** Binds

      #+BEGIN_SRC emacs-lisp

      (define-key text-mode-map (kbd "C-c C-g") 'keyboard-quit)
      (define-key text-mode-map (kbd "TAB") 'eos/complete-buffer-or-indent)

      (define-key text-mode-map (kbd "C-c C-k") 'with-editor-cancel)
      (define-key text-mode-map (kbd "C-c C-c") 'with-editor-finish)

      #+END_SRC

***** Hooks

      #+BEGIN_SRC emacs-lisp

      (add-hook 'text-mode-hook
                (lambda ()
                  ;; turn on auto fill mode
                  (turn-on-auto-fill)

                  ;; set company backends
                  (eos-set-company-backends
                   '((company-ispell
                      company-dabbrev)
                     (company-files)))))))

      #+END_SRC

**** Markdown

     Major mode for editing Markdown files.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'markdown-mode nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      (customize-set-variable 'markdown-command "multimarkdown")))

      #+END_SRC

***** Binds

      #+BEGIN_SRC emacs-lisp

      (when (boundp 'markdown-mode-map)
        (progn
          (define-key markdown-mode-map (kbd "TAB") 'eos/complete-buffer-or-indent)))

      #+END_SRC

**** DocView

     DocView is a document viewer for Emacs.  It converts PDF, PS and DVI files
     to a set of PNG files, one PNG for each page, and displays the PNG images
     inside an Emacs buffer.  This buffer uses `doc-view-mode' which provides
     convenient key bindings for browsing the document.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'doc-view nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; the base directory, where the PNG images will be saved
      (customize-set-variable
       'doc-view-cache-directory
       (concat (expand-file-name user-emacs-directory) "cache/docview"))

      ;; in continuous mode reaching the page edge advances to next/previous page
      (customize-set-variable 'doc-view-continuous t)))

      #+END_SRC

**** Pdf-tools
**** Dictionary

     Dictionary allows you to interact with dictionary servers.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'dictionary nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; create some clickable buttons on top of the window if non-nil
      (customize-set-variable 'dictionary-create-buttons nil)

      ;; should the dictionary command reuse previous dictionary buffers?
      (customize-set-variable 'dictionary-use-single-buffer t)

      #+END_SRC

***** Functions

      #+BEGIN_SRC emacs-lisp

      (defun eos/dictionary-search-at-point ()
        "Dictionary with word at point as its arguments."
        (interactive)
        (let ((word (thing-at-point 'word)))
          (unless word
            (setq word (read-string "Word: ")))
          (if word
              (when (fboundp 'dictionary-search)
                (dictionary-search word))
            (message "Missing word"))))

      #+END_SRC

***** Binds

      #+BEGIN_SRC emacs-lisp

      ;; binds
      (define-key eos-docs-map (kbd ".") 'eos/dictionary-search-at-point)))

      #+END_SRC

*** Translators
**** Google-Translate

     Google translate interface.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (and (require 'google-translate nil t)
                 (require 'google-translate-smooth-ui nil t))
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; alist of translation directions
      ;; each of direction could be selected directly in
      ;; the minibuffer during translation.
      (customize-set-variable
       'google-translate-translation-directions-alist
       '(("pt" . "en") ("en" . "pt")))

      ;; default target language
      (customize-set-variable
       'google-translate-default-target-language "pt")

      ;; default source language
      ;; "auto" if you want Google Translate to always detect the source language
      (customize-set-variable 'google-translate-default-source-language
                              "auto")

      ;; determines where translation output will be displayed, if
      ;; `nil' the translation output will be displayed in the pop up
      ;; buffer (default).
      (customize-set-variable 'google-translate-output-destination nil)))

      #+END_SRC

*** Notification
**** Notifications

     For proper usage, Emacs must be started in an environment with an
     active D-Bus session bus.

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'notifications nil t)

      #+END_SRC

*** Documentation
**** Eldoc

     As you type a function's symbol name as part of a sexp,
     it will print the argument list for that function.
     Behavior is not identical; for example, you need not actually
     type the function name, you need only move point around in a sexp that
     calls it.  Also, if point is over a documented variable, it will print
     the one-line documentation for that variable instead, to remind you of
     that variable's meaning.

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'eldoc nil t)

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; number of seconds of idle time to wait before printing.
      (customize-set-variable 'eldoc-idle-delay 0)

      #+END_SRC

**** Man

     This package provides a function, `man', with which you can browse
     UNIX manual pages. Formatting is done in background so that you
     can continue to use your Emacs while processing is going on.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'man nil t)
        (progn

      #+END_SRC

***** Hooks

      #+BEGIN_SRC emacs-lisp

      (add-hook 'Man-mode-hook
                (lambda ()
                  ;; don't truncate lines
                  (setq truncate-lines nil)))

      #+END_SRC

***** Binds

      #+BEGIN_SRC emacs-lisp

      (when (boundp 'Man-mode-map)
        (progn
          (define-key Man-mode-map (kbd "C-j") 'push-button)))

      ;; eos-docs-map docs actions prefix map
      (define-key eos-docs-map (kbd "m") 'man)))

      #+END_SRC

**** Woman

     WoMan implements a subset of the formatting performed by the Emacs
     `man' (or `manual-entry') command to format a UN*X manual `page'
     for display, but without calling any external programs.

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'woman nil t)

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; if non-nil then show the *WoMan-Log* buffer if appropriate
      (customize-set-variable 'woman-show-log nil)

      #+END_SRC

**** Dash-docs

     This package exposes functionality to work with and search dash
     docsets.

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'dash-docs nil t)

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; default path for docsets
      (customize-set-variable
       'dash-docs-docsets-path
       (concat (expand-file-name user-emacs-directory) "docsets"))

      ;; minimum length to start searching in docsets
      (customize-set-variable 'dash-docs-min-length 2)

      #+END_SRC

***** Functions

      #+BEGIN_SRC emacs-lisp

      (defun eos/icomplete/dash-docs-search ()
        "Provide dash-docs candidates to `icomplete."
        (interactive)
        (dash-docs-create-common-connections)
        (dash-docs-create-buffer-connections)

        ;; get candidates
        (let* ((candidates (cl-loop for docset in (dash-docs-maybe-narrow-docsets "")
                                    appending (dash-docs-search-docset docset "")))
               (candidate (completing-read "Docs for: " candidates nil nil)))
          ;; parse candidate
          (let* ((i 0)
                 (n (catch 'nth-elt
                      (dolist (value candidates)
                        (when (equal candidate (car value))
                          (throw 'nth-elt i))
                        (setq i (+ 1 i)))))
                 (search-result (nth n candidates)))
            (pop search-result)

            ;; action: open documentation file
            (dash-docs-browse-url search-result))))

      (defun eos-set-dash-docset (docset)
        "Activate a DOCSET, if available."
        (when (fboundp 'dash-docs-activate-docset)
          (funcall 'dash-docs-activate-docset docset)))

      #+END_SRC

***** Binds

      #+BEGIN_SRC emacs-lisp

      ;; eos-docs-map
      (define-key eos-docs-map (kbd "u") 'dash-docs-update-docset)
      ;; (define-key eos-docs-map (kbd "i") 'dash-docs-async-install-docset)
      (define-key eos-docs-map (kbd "i") 'dash-docs-install-docset)
      (define-key eos-docs-map (kbd "l") 'eos/icomplete/dash-docs-search)
      (define-key eos-docs-map (kbd "a") 'dash-docs-activate-docset)
      (define-key eos-docs-map (kbd "d") 'dash-docs-deactivate-docset)

      #+END_SRC

**** Rfc-mode

     Mode so browser local RFC files. To make it work, just download
     the RFC files and changhe the 'rfc-mode-directory' dir to match
     the path where all the RFCs were extracted.

     The RFC collection can be downloaded [[https://www.rfc-editor.org/retrieve/bulk][here]].

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'rfc-mode nil t)
        (progn

      #+END_SRC

***** Bind

#+BEGIN_SRC emacs-lisp
      ;; bind
      (define-key eos-docs-map (kbd "r") 'rfc-mode-browse)
#+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; change color from section title to match theme
      (custom-set-faces
        '(rfc-mode-document-section-title-face ((t (:inherit nil :foreground "indian red")))))

      ;; the directory where RFC documents are stored
      (customize-set-variable
       'rfc-mode-directory
       (concat (expand-file-name user-emacs-directory) "rfc/"))))

      #+END_SRC

*** Completion
**** Company

     Company is a modular completion framework.
     Modules for retrieving completion candidates are called backends,
     modules for displaying them are front-ends.

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'company nil t)

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; set echo delay
      (customize-set-variable 'company-echo-delay 0.2)

      ;; idle delay in seconds until completion starts automatically
      (customize-set-variable 'company-idle-delay nil)

      ;; maximum number of candidates in the tooltip
      (customize-set-variable 'company-tooltip-limit 8)

      ;; set minimum prefix length
      (customize-set-variable 'company-minimum-length 2)

      ;; if enabled, selecting item before first or after last wraps around
      (customize-set-variable 'company-selection-wrap-around t)

      ;; sort by frequency
      (customize-set-variable 'company-transformers
                              '(company-sort-by-occurrence))

      ;; whether to downcase the returned candidates.
      (customize-set-variable 'company-dabbrev-downcase t)

      ;; if enabled, disallow non-matching input
      (customize-set-variable 'company-require-match nil)

      ;; When non-nil, align annotations to the right tooltip border
      (customize-set-variable 'company-tooltip-align-annotations nil)

      ;; show candidates number
      ;; to select completions use: M-1, M-2, etc..
      (customize-set-variable 'company-show-numbers t)

      #+END_SRC

***** Functions

      #+BEGIN_SRC emacs-lisp

      (defun eos/icomplete/company ()
        "Insert the selected company candidate directly at point."
        (interactive)
        (if (and
             (boundp 'company-common)
             (boundp 'company-candidates)
             (fboundp 'company-complete))
            (progn
              (unless company-candidates
                (company-complete))
              (unless (= (length company-candidates) 0)
                (let ((candidate (completing-read "ic-company: " company-candidates nil nil)))
                  (delete-char (- (length company-common)))
                  (insert candidate))))
          nil))

      (defun eos-set-company-backends (backends)
        "Set company back ends with BACKENDS."
        (make-local-variable 'company-backends)
        (when (boundp 'company-backends)
          (setq company-backends backends)))

      #+END_SRC

***** Binds

      #+BEGIN_SRC emacs-lisp

      ;; company-active-map
      (when (boundp 'company-active-map)
        (progn
          (define-key company-active-map (kbd "TAB") 'company-complete-common)
          (define-key company-active-map (kbd "C-j") 'company-complete-selection)
          (define-key company-active-map (kbd "C-n") 'company-select-next)
          (define-key company-active-map (kbd "C-p") 'company-select-previous)))

      ;;eos-complete map
      (define-key eos-complete-map (kbd "TAB") 'company-ispell)
      (define-key eos-complete-map (kbd "f") 'company-files)
      (define-key eos-complete-map (kbd "g") 'company-gtags)

      #+END_SRC

***** Enable

      #+BEGIN_SRC emacs-lisp

      ;; enable globally
      (eos-call-func 'global-company-mode 1)

      #+END_SRC

**** Company-statistics

     Every time a candidate is chosen using company-mode, we keep track of this
     (for a limited amount of recent choices). When presenting completion
     candidates next time, they are sorted according to the score thus acquired.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'company-statistics nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; set company-statistics cache location
      (customize-set-variable
       'company-statistics-file
       (concat user-emacs-directory "cache/company-statistics-cache.el"))

      #+END_SRC

***** Hooks

      #+BEGIN_SRC emacs-lisp

      (add-hook 'company-mode-hook 'company-statistics-mode)))

      #+END_SRC

**** Yasnippet

     YASnippet is a template system for Emacs. It allows you to type an
     abbreviation and automatically expand it into
     function templates. Bundled language templates include:
     C, C++, C#, Perl, Python, Ruby, SQL, LaTeX, HTML, CSS and more.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'yasnippet nil t)
        (progn

      #+END_SRC

***** Binds

      #+BEGIN_SRC emacs-lisp

      (define-key eos-complete-map (kbd "e") 'yas-expand)
      (define-key eos-complete-map (kbd "i") 'yas-insert-snippet)
      (define-key eos-complete-map (kbd "v") 'yas-visit-snippet-file)))

      (when (boundp 'yas-keymap)
        (progn
          (define-key yas-keymap (kbd "<tab>") nil)
          (define-key yas-keymap (kbd "M-`") 'yas-next-field)))

      #+END_SRC

***** Enable

      #+BEGIN_SRC emacs-lisp

      (eos-call-func 'yas-global-mode 1)

      #+END_SRC

*** Navigation
**** Imenu

     This package provide a framework for mode-specific buffer indexes.
     A buffer index is an alist of names and buffer positions.
     For instance all functions in a C-file and their positions.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'imenu nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; use a popup menu rather than a minibuffer prompt (no)
      (customize-set-variable 'imenu-use-popup-menu nil)

      #+END_SRC

***** Binds

      #+BEGIN_SRC emacs-lisp

      (define-key eos-tags-map (kbd "i") 'imenu)))

      #+END_SRC

*** Debugging
**** Gud

     The GUD (Grand Unified Debugger) library provides an Emacs interface to
     a wide variety of symbolic debuggers.  It can run the GNU Debugger
     (GDB), as well as DBX, SDB, XDB, Guile REPL debug commands, Perl’s
     debugging mode, the Python debugger PDB, and the Java Debugger
     JDB.

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'gud nil t)

      #+END_SRC

**** Rmsbolt

     A compiler output viewer.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'rmsbolt nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; which output assembly format to use.
      (customize-set-variable 'rmsbolt-asm-format "att")

      ;;    whether we should disassemble an output binary
      (customize-set-variable 'rmsbolt-disassemble t)

      ;; rmsbolt mode lighter
      (customize-set-variable 'rmsbolt-mode-lighter "RMS")))

      #+END_SRC

*** Building
**** Cmake-ide

     This package runs CMake and sets variables for IDE-like functionality
     provided by other packages such as:
     On the fly syntax checks with flycheck
     auto-completion using auto-complete-clang or company-clang.
     Jump to definition and refactoring with rtags.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'cmake-ide nil t)
        (progn

      #+END_SRC

***** Hooks

      #+BEGIN_SRC emacs-lisp

      (add-hook 'c-mode-hook 'cmake-ide-setup)
      (add-hook 'c++-mode-hook 'cmake-ide-setup)))

      #+END_SRC

*** Compilation
**** Compile

     Emacs can run compilers for languages such as C and Fortran, feeding the
     compilation log into an Emacs buffer.  It can also parse the error
     messages and show you where the errors occurred.

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'compile nil t)

      #+END_SRC

***** Functions

      #+BEGIN_SRC emacs-lisp

      (defun eos-compile (dir command)
        "Compile COMMAND at specific DIR.
           Just a `compile` function wrapper."
        (interactive)
        (if (file-exists-p dir)
            (let ((default-directory dir))
              (compile command))))

      #+END_SRC

***** Hooks

      #+BEGIN_SRC emacs-lisp

      ;; don't truncate lines
      (add-hook 'compilation-mode-hook
                (lambda ()
                  (setq truncate-lines nil)))

      ;; fix compilation buffer colors
      (add-hook 'compilation-filter-hook
                (lambda ()
                  (when (eq major-mode 'compilation-mode)
                    (ansi-color-apply-on-region
                     compilation-filter-start (point-max)))))

      #+END_SRC

*** Versioning

    Version control packages.

**** Magit

     Magit is an interface to the version control system Git,
     implemented as an Emacs package.  Magit aspires to be a complete
     Git porcelain.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'magit nil t)
        (progn

      #+END_SRC

***** Binds

      #+BEGIN_SRC emacs-lisp

      (define-key ctl-x-map (kbd "j") 'magit-status)))

      #+END_SRC

*** Projects
**** Ede

     EDE is the top level Lisp interface to a
     project management scheme for Emacs.

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'ede nil t)

      #+END_SRC

**** Projectile

     This package provides easy project management and navigation.
     The concept of a project is pretty basic - just a folder containing
     special file. Currently git, mercurial and bazaar repos are
     considered projects by default. If you want to mark a folder
     manually as a project just create an empty .projectile file in it.

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'projectile nil t)

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; enable cache and choose indexing method
      (customize-set-variable 'projectile-enable-caching t)
      (customize-set-variable 'projectile-indexing-method 'hybrid)
      (customize-set-variable 'projectile-completion-system 'default)

      ;; set bookmarks file localtion (cache)
      (customize-set-variable 'projectile-known-projects-file
                              (concat user-emacs-directory "cache/projectile-bookmarks.eld"))

      (customize-set-variable 'projectile-cache-file
                              (concat user-emacs-directory "cache/projectile.cache"))

      #+END_SRC

***** Binds

      #+BEGIN_SRC emacs-lisp

      (define-key eos-pm-map (kbd "g") 'projectile-grep)
      (define-key eos-pm-map (kbd "t") 'projectile-find-tag)
      (define-key eos-pm-map (kbd "f") 'projectile-find-file)
      (define-key eos-pm-map (kbd "<f5>") 'projectile-compile-project)
      (define-key eos-pm-map (kbd "&") 'projectile-run-eshell)
      (define-key eos-pm-map (kbd "o") 'projectile-switch-project)
      (define-key eos-pm-map (kbd "r") 'projectile-replace-regexp)
      (define-key eos-pm-map (kbd "R") 'projectile-replace)
      (define-key eos-pm-map (kbd "s") 'projectile-save-project-buffers)
      (define-key eos-pm-map (kbd "d") 'projectile-discover-projects-in-directory)
      (define-key eos-pm-map (kbd "c") 'projectile-cleanup-known-projects)
      (define-key eos-pm-map (kbd "C") 'projectile-invalidate-cache)
      (define-key eos-pm-map (kbd "U") 'projectile-purge-dir-from-cache)
      (define-key eos-pm-map (kbd "u") 'projectile-purge-file-from-cache)
      (define-key eos-pm-map (kbd ".") 'projectile-edit-dir-locals)
      (define-key eos-pm-map (kbd "k") 'projectile-kill-buffers)
      (define-key eos-pm-map (kbd "D") 'projectile-remove-known-project)

      #+END_SRC

***** Enable

      #+BEGIN_SRC emacs-lisp

      (eos-call-func 'projectile-mode 1)

      #+END_SRC

** Programming
*** C/C++
**** Rtags

     RTags is a client/server application that indexes C/C++ code and keeps a
     persistent file-based database of references, declarations, definitions,
     symbolnames etc. There’s also limited support for ObjC/ObjC++.

***** Functions

      #+BEGIN_SRC emacs-lisp

      (defun eos/cc/load-rtags ()
        "Load rtags manually."
        (eos-load-file (concat user-emacs-directory "rtags/src/rtags.el"))

        ;; set rtags binary path
        (customize-set-variable
         'rtags-path
         (concat user-emacs-directory "rtags/build/bin/"))

        ;; method to use to display RTags results, like references
        (customize-set-variable 'rtags-display-result-backend 'default)

        ;; behavior for completing-read
        (customize-set-variable 'rtags-completing-read-behavior 'insert-default-marked))

      #+END_SRC

***** Binds

      #+BEGIN_SRC emacs-lisp

      ;; eos-rtags-map
      (define-key eos-rtags-map (kbd "l") 'rtags-taglist)
      (define-key eos-rtags-map (kbd "I") 'rtags-install)
      (define-key eos-rtags-map (kbd "y") 'rtags-symbol-type)
      (define-key eos-rtags-map (kbd "l") 'rtags-symbol-info)
      (define-key eos-rtags-map (kbd "n") 'rtags-rename-symbol)
      (define-key eos-rtags-map (kbd "m") 'rtags-asm-file)
      (define-key eos-rtags-map (kbd "h") 'rtags-find-file-history)
      (define-key eos-rtags-map (kbd "x") 'rtags-fixit)
      (define-key eos-rtags-map (kbd "d") 'rtags-diagnostics)
      (define-key eos-rtags-map (kbd "c") 'rtags-compile-file)
      (define-key eos-rtags-map (kbd "-") 'rtags-compilation-flags)
      (define-key eos-rtags-map (kbd ".") 'rtags-find-functions-called-by-this-function)

      #+END_SRC

**** CC-mode

     This package provides GNU Emacs major modes for editing C, C++,
     Objective-C, Java, CORBA's IDL, Pike and AWK code.  As of the
     latest Emacs and XEmacs releases, it is the default package for
     editing these languages.  This package is called "CC Mode", and
     should be spelled exactly this way.

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'cc-mode nil t)

      #+END_SRC

***** Functions

      #+BEGIN_SRC emacs-lisp

      ;; c/c++ company backends
      (defun eos/cc/set-company-backends ()
        "Set C/C++ common company backends."
        (eos-set-company-backends
         '((company-c-headers)
           (company-irony
            company-yasnippet
            company-dabbrev-code)
           (company-files))))

      #+END_SRC

***** Hooks

      #+BEGIN_SRC emacs-lisp

      (add-hook 'c-mode-hook
                (lambda ()
                  ;; set cc common company backends
                  (eos/cc/set-company-backends)

                  ;; set dash docset
                  (eos-set-dash-docset '"C")

                  ;; set flycheck checker
                  (eos/set-flycheck-checker 'c/c++-clang)

                  ;; load rtags
                  (eos/cc/load-rtags)))

      (add-hook 'c++-mode-hook
                (lambda ()
                  ;; set cc common backends (company and flycheck)
                  (eos/cc/set-company-backends)

                  ;; set flycheck checker
                  (eos/set-flycheck-checker 'c++-cppcheck)

                  ;; set dash docset
                  (eos-set-dash-docset '"C++")

                  ;; load rtags
                  (eos/cc/load-rtags)))

      #+END_SRC

***** Binds

      #+BEGIN_SRC emacs-lisp

      ;; c-mode-map
      (when (boundp 'c-mode-map)
        (progn
          ;; set rtags prefix map in c-mode map (C-c r)
          (define-key c-mode-map (kbd "C-c r") 'eos-rtags-map)

          ;; complete or indent
          (define-key c-mode-map (kbd "TAB") 'eos/complete-buffer-or-indent)))

      ;; c++-mode-map
      (when (boundp 'c++-mode-map)
        (progn
          ;; set rtags prefix map in c-mode map (C-c r)
          (define-key c++-mode-map (kbd "C-c r") 'eos-rtags-map)

          ;; complete or indent
          (define-key c++-mode-map (kbd "TAB") 'eos/complete-buffer-or-indent)))

      #+END_SRC

**** Irony

     Irony-mode is an Emacs minor-mode that aims at improving the
     editing experience for the C, C++ and Objective-C
     languages. It works by using a combination of an
     Emacs package and a C++ program (irony-server) exposing libclang.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'irony nil t)
        (progn

      #+END_SRC

***** Hooks

      #+BEGIN_SRC emacs-lisp

      ;; irony-mode hooks
      (add-hook 'irony-mode-hook 'electric-pair-mode)

      ;; cc-mode hooks
      (add-hook 'c-mode-hook 'irony-mode)
      (add-hook 'c++-mode-hook 'irony-mode)
      (add-hook 'objc-mode-hook 'irony-mode)))

      #+END_SRC

**** Irony-cdb

     This package provides a compilation database interface of irony-mode.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'irony-cdb nil t)
        (progn

      #+END_SRC

***** Hooks

      #+BEGIN_SRC emacs-lisp

      ;; hooks
      (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)))

      #+END_SRC

**** Company-irony

     This package provides a company-mode asynchronous
     completion backend for the C, C++ and Objective-C languages.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'company-irony nil t)
        (progn

      #+END_SRC

***** Hooks

      #+BEGIN_SRC emacs-lisp

      (add-hook 'irony-mode-hook 'company-irony-setup-begin-commands)))

      #+END_SRC

**** Company-c-headers

     This library enables the completion of C/C++ header file names
     using Company mode for Emacs.

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'company-c-headers nil t)

      #+END_SRC

*** Lisp
**** Lisp-mode

     The base major mode for editing Lisp code (used also for Emacs Lisp).
     This mode is documented in the Emacs manual.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'lisp-mode nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; number of columns to indent the second line of a (def...) form
      (customize-set-variable 'lisp-body-indent 2)))

      #+END_SRC

*** Elisp
**** Elisp-mode

     The major mode for editing Emacs Lisp code.
     Tis mode is documented in the Emacs manual.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'elisp-mode nil t)
        (progn

      #+END_SRC

***** Hooks

      #+BEGIN_SRC emacs-lisp

      ;; enable minor modes
      (add-hook 'emacs-lisp-mode-hook
                (lambda()
                  (eos-call-func 'eldoc-mode 1)))

      (add-hook 'lisp-interaction-mode-hook
                (lambda()
                  (eos-call-func 'eldoc-mode 1)))

      ;; set backends (company, flychecker, dash-docs)
      (add-hook 'emacs-lisp-mode-hook
                (lambda ()
                  ;; set company backends
                  (eos-set-company-backends
                   '((company-elisp
                      company-yasnippet
                      company-dabbrev-code)
                     (company-files)))

                  ;; set flycheck checker
                  (eos/set-flycheck-checker 'emacs-lisp)

                  ;; activate dash docset (emacs)
                  (eos-set-dash-docset "Emacs Lisp")))

      #+END_SRC

***** Binds

      #+BEGIN_SRC emacs-lisp

      ;; emacs-lisp-mode-map
      (when (boundp 'emacs-lisp-mode-map)
        (progn
          ;; eval
          (define-key emacs-lisp-mode-map (kbd "C-c C-f") 'eval-defun)
          (define-key emacs-lisp-mode-map (kbd "C-c C-r") 'eval-region)
          (define-key emacs-lisp-mode-map (kbd "C-c C-c") 'eval-buffer)

          ;; complete
          (define-key emacs-lisp-mode-map (kbd "<tab>") 'eos/complete-buffer-or-indent)

          ;; quality of life (unbind)
          (define-key emacs-lisp-mode-map (kbd "DEL") 'nil)
          (define-key emacs-lisp-mode-map (kbd "ESC") 'nil)
          (define-key emacs-lisp-mode-map (kbd "C-x") 'nil)
          (define-key emacs-lisp-mode-map (kbd "C-M-x") 'nil)
          (define-key emacs-lisp-mode-map (kbd "C-M-q") 'nil)))))

      #+END_SRC

**** Company-elisp

     Company completion backend for Emacs Lisp.

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'company-elisp nil t)

      #+END_SRC

*** ShellScript
**** Sh-script

     Major mode for editing shell scripts. Bourne, C and rc shells as well
     as various derivatives are supported and easily derived from. Structured
     statements can be inserted with one command or abbrev. Completion is
     available for filenames, variables known from the script, the shell and
     the environment as well as commands.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'sh-script nil t)
        (progn

      #+END_SRC

***** Hooks

      #+BEGIN_SRC emacs-lisp

      (add-hook 'sh-mode-hook
                (lambda ()
                  ;; set company backends
                  (eos-set-company-backends
                   '((company-shell
                      company-shell-env
                      company-yasnippet
                      company-dabbrev-code)
                     (company-files)))

                  ;; set flycheck backends
                  (eos/set-flycheck-checker 'sh-shellcheck)))))

      #+END_SRC

**** Fish-mode

     Major mode for editing Fish shell files.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'fish-mode nil t)
        (progn

      #+END_SRC

***** Hooks

      #+BEGIN_SRC emacs-lisp

      (add-hook 'fish-mode-hook
                (lambda ()
                  ;; set company backends
                  (eos-set-company-backends
                   '((company-fish-shell
                      company-yasnippet
                      company-shell
                      company-shell-env
                      company-dabbrev-code)
                     (company-files)))))))

      #+END_SRC

**** Company-shell

     Backend for company mode to complete environment variables, binaries found
     on your $PATH and fish shell functions.

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'company-shell nil t)

      #+END_SRC

*** Lua
**** Lua-mode

     Major mode for editing Lua files.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'lua-mode nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; non-nil means display lua-process-buffer after sending a command.
      (customize-set-variable 'lua-process-buffer t)

      ;; default application to run in Lua process
      (customize-set-variable 'lua-default-application "lua")

      ;; command switches for lua-default-application
      (customize-set-variable 'lua-default-command-switches "-i")

      ;; amount by which Lua subexpressions are indented
      (customize-set-variable 'lua-indent-level 4)

      ;; if non-nil, contents of multiline string will be indented
      (customize-set-variable 'lua-indent-string-contents t)

      ;; jump to innermost traceback location in *lua* buffer
      ;; when this variable is non-nil and a traceback occurs
      ;; when running Lua code in a process, jump immediately
      ;; to the source code of the innermost traceback location
      (customize-set-variable 'lua-jump-on-traceback t)

      #+END_SRC

***** Hooks

      #+BEGIN_SRC emacs-lisp

      (add-hook 'lua-mode-hook
                (lambda ()
                  ;; set company backends
                  (eos-set-company-backends
                   '((company-yasnippet
                      company-keywords
                      company-gtags
                      company-dabbrev
                      company-dabbrev-code
                      company-keywords)
                     (company-files)))

                  ;; set flycheck checker
                  (eos/set-flycheck-checker 'lua)

                  ;; activate dash docset
                  (eos-set-dash-docset "Lua")))

      #+END_SRC

***** Enable

      #+BEGIN_SRC emacs-lisp

      ;; add auto-mode
      (add-to-list 'auto-mode-alist '("\\.lua$" . lua-mode))
      (add-to-list 'interpreter-mode-alist '("lua" . lua-mode))))

      #+END_SRC

*** Tcl
**** Tcl

     Major mode for editing Tcl files.

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'tcl nil t)

      #+END_SRC

*** Perl
**** Cperl-mode

     Major mode for editing Perl files.

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'cperl-mode nil t)

      #+END_SRC

*** Python
**** Python

     Major mode for editing Python files with some fontification and
     indentation bits extracted from original Dave Love's python.el
     found in GNU/Emacs.

     Implements Syntax highlighting, Indentation, Movement, Shell
     interaction, Shell completion, Shell virtualenv support, Shell
     package support, Shell syntax highlighting, Pdb tracking, Symbol
     completion, Skeletons, FFAP, Code Check, Eldoc, Imenu.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'python nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; default Python interpreter for shell
      (customize-set-variable 'python-shell-interpreter "python")

      ;; non-nil means template skeletons will be automagically inserted
      (customize-set-variable 'python-skeleton-autoinsert t)

      #+END_SRC

***** Hooks

      #+BEGIN_SRC emacs-lisp

      ;; enable modes
      (add-hook 'python-mode-hook
                (lambda()
                  ;; enable eldoc mode
                  (eos-call-func 'eldoc-mode 1)))

      ;; set backends
      (add-hook 'python-mode-hook
                (lambda ()
                  ;; set company backends
                  (eos-set-company-backends
                   '((company-yasnippet
                      company-keywords
                      company-dabbrev-code)
                     (company-files)))

                  ;; set flycheck checker
                  (eos/set-flycheck-checker 'python-pycompile)

                  ;; set dash docsets
                  (eos-set-dash-docset '"Python 3")))))

      #+END_SRC

*** Go
**** Go-mode

     The major mode for editing Go files.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'go-mode nil t)
        (progn

      #+END_SRC

***** Hooks

      #+BEGIN_SRC emacs-lisp

      (add-hook 'go-mode-hook
                (lambda ()
                  ;; set company backends
                  (eos-set-company-backends
                   '((company-yasnippet
                      company-keywords
                      company-dabbrev-code)
                     (company-files)))

                  ;; set flycheck checker (go lint)
                  (eos/set-flycheck-checker 'go-golint)

                  ;; set dash docsets
                  (eos-set-dash-docset '"Go")))

      #+END_SRC

***** Enable

      #+BEGIN_SRC emacs-lisp

      ;; add (*.go . go-mode) to auto-mode-alist
      ;; init go-mode when a file with the extersion .go is opened
      (add-to-list 'auto-mode-alist '("\\.go\\'" . go-mode))))

      #+END_SRC

*** R
**** Ess-r-mode

     Major mode for editing R source.

     This package defines all the R customizations for ESS.
     See ess-s-lang.el for general S language customizations.

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'ess-r-mode nil t)

      #+END_SRC

*** Julia
**** Julia-mode

     Major mode for editing julia code. This is the official Emacs
     mode for editing Julia programs.

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'julia-mode nil t)

      #+END_SRC

**** Ess-julia
***** Require

      Major mode for editing julia files.

      Customize inferior-julia-program to point to your julia binary
      and start the inferior interpreter with M-x julia.

      #+BEGIN_SRC emacs-lisp

      (require 'ess-julia nil t)

      #+END_SRC

*** C#
**** Csharp-mode

     This is a major mode for editing C# files.
     It performs automatic indentation of C# syntax;
     font locking; and integration with imenu.el.

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'csharp-mode nil t)

      #+END_SRC

*** Clojure
*** Elixir
**** Elixir-mode

     Provides font-locking, indentation and navigation support
     for the Elixir programming language.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'elixir-mode nil t)
        (progn

      #+END_SRC

***** Customize

      #+BEGIN_SRC emacs-lisp

      ;; additional arguments to `mix format`'
      ;; (customize-set-variable 'elixir-format-arguments nil)

      #+END_SRC

***** Hooks

      #+BEGIN_SRC emacs-lisp

      (add-hook 'elixir-mode-hook
                (lambda ()
                  ;; set company backends
                  (eos-set-company-backends
                   '((company-yasnippet
                      company-keywords
                      company-dabbrev-code)
                     (company-files)))

                  ;; set syntax checker
                  ;; eos/flycheck/set-cheker '<elixir-checker>)

                  ;; set dash docsets
                  (eos-set-dash-docset '"Elixir")))))

      #+END_SRC

*** Vhdl
**** Vhdl-mode

     Major mode for editing VHDL files.

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'vhdl-mode nil t)

      #+END_SRC

*** Verilog
**** Verilog

     A major mode for editing Verilog and SystemVerilog HDL source code (IEEE
     1364-2005 and IEEE 1800-2012 standards).

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'verilog nil t)

      #+END_SRC

*** Cmake
**** Cmake-mode

     Provides syntax highlighting and indentation for CMakeLists.txt and
     *.cmake source files.

***** Require

      #+BEGIN_SRC emacs-lisp

      (require 'cmake-mode nil t)

      #+END_SRC

*** Mql\
**** Mql-mode

     Major mode for editing Mql files: work in progress!

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'mql-mode nil t)
        (progn

      #+END_SRC

***** Hooks

      #+BEGIN_SRC emacs-lisp

      (add-hook 'mql-mode-hook
                (lambda ()
                  ;; set company backends
                  (eos-set-company-backends
                   '((company-gtags
                      company-yasnippet
                      company-dabbrev
                      company-dabbrev-code)
                     (company-files)))

                  ;; select flycheck checker (use gcc)
                  (eos/set-flycheck-checker 'c/c++-gcc)

                  ;; activate mql5 docset
                  (eos-set-dash-docset '"mql5")))))

      #+END_SRC

*** Web
**** Web-mode

     Web-mode is an emacs major mode for editing web templates aka
     HTML files embedding parts (CSS/JavaScript) and blocks
     (pre rendered by client/server side engines).

     Web-mode compatible with many template engines: PHP, JSP, ASP,
     Django, Twig, Jinja, Mustache, ERB, FreeMarker,
     Velocity, Cheetah, Smarty, CTemplate, Mustache, Blade, ErlyDTL,
     Go Template, Dust.js, Google Closure (soy), React/JSX,
     Angularjs, ejs, Nunjucks, etc.

***** Require

      #+BEGIN_SRC emacs-lisp

      (when (require 'web-mode nil t)
        (progn

      #+END_SRC

***** Enable

      #+BEGIN_SRC emacs-lisp

      ;; add files extensions to web-mode
      (add-to-list 'auto-mode-alist '("\\.php\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))))

      (when (boundp 'web-mode-engines-alist)
        (progn
          (add-to-list 'web-mode-engines-alist '(("php" . "\\.phtml\\'")))))

      #+END_SRC

** Epilogue

   The adapt.el script will be the last think
   loaded after ~init.el~, you can put more =elisp= code
   there to add more junk to this already bloated configuration.

   #+BEGIN_SRC emacs-lisp

   (eos-load-file (expand-file-name "adapt.el" user-emacs-directory))

   #+END_SRC

** EOF

   "See You Space Cowboy.."
   | Cowboy Bebop |
