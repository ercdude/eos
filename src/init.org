#+TITLE: Emacs Configuration File
#+AUTHOR: Isaac "esac-io"
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes

* EOS

  Using emacs (lisp interpreter) as the only IO bridge
  between human and machine.

** Bootstrap
*** Header

    Define the package header to avoid warnings.

    #+BEGIN_SRC emacs-lisp

    ;;; Package --- eos
    ;;; Commentary: ... Present day, present time ....
    ;;; Code:

    #+END_SRC

*** Lexical

    Lexical binding opens up many more opportunities
    for optimization, so programs using it are likely to run
    faster in future Emacs versions.

    Lexical binding is also more compatible with concurrency,
    which was added to Emacs in version 26.1.

    #+BEGIN_SRC emacs-lisp

    ;;; -*- lexical-binding: t -*-

    #+END_SRC

*** Version

    Verify emacs version.

    #+BEGIN_SRC emacs-lisp

    (when (version< emacs-version "26.3")
      (error "This requires Emacs 26.3 and above!"))

    #+END_SRC

*** Literate

    Literate programming is a programming paradigm
    introduced by Donald Knuth in which a computer program is
    given an explanation of its logic in a natural language,
    such as English, interspersed with snippets of macros and
    traditional source code, from which compilable source code
    can be generated.

    Literate programming it's only possible thanks to org-mode.

    #+BEGIN_SRC emacs-lisp

    (require 'org nil t)

    ;; load languages (reference)
    ;; (org-babel-do-load-languages 'org-babel-load-languages
    ;;                              '((emacs-lisp . t)))))

    #+END_SRC

*** Garbage Collector

    This works surprisingly well. While the minibuffer is open,
    garbage collection will never occur, but once we
    make a selection, or cancel, garbage collection will kick
    off immediately and then revert back to the default,
    sensible behavior.

    #+BEGIN_SRC emacs-lisp

    (defun eos/gc/defer-gc-collection ()
      "Set 'gc-cons-threshold most-positive-fixnum."
      (setq gc-cons-threshold most-positive-fixnum))

    (defun eos/gc/restore-gc-collection ()
      "Defer garbage collection."
      (run-at-time
       1 nil (lambda () (setq gc-cons-threshold 16777216))))

    ;; threshold inital value
    (setq gc-cons-threshold most-positive-fixnum ; 2^61 bytes
          gc-cons-percentage 0.5)

    ;; hooks
    (add-hook 'emacs-startup-hook
              (lambda ()
                (setq gc-cons-threshold 16777216 ; 16mb
                      gc-cons-percentage 0.1)))

    ;; defer garbage collection
    (add-hook 'minibuffer-setup-hook 'eos/gc/defer-gc-collection)

    ;; reset threshold to inital value
    (add-hook 'minibuffer-exit-hook 'eos/gc/restore-gc-collection)

    #+END_SRC

*** Defer

    Used to seep up the emacs startup time.

    #+BEGIN_SRC emacs-lisp

    (defvar eos-file-name-handler-alist
      file-name-handler-alist
      "Save file-name-handler-alist")

    ;; clean file-name-handler-alist
    (setq file-name-handler-alist nil)

    ;; hooks
    ;; restore file-name-handler-alist
    (add-hook 'emacs-startup-hook
              (lambda ()
                (setq file-name-handler-alist eos-file-name-handler-alist)))

    #+END_SRC

*** Defines
**** Aliases

     Define some aliases to improve quality of life.

     #+BEGIN_SRC emacs-lisp

     ;; y or n
     (defalias 'yes-or-no-p 'y-or-n-p)

     #+END_SRC

**** Keymaps

     Basically we creates new maps prefix maps.

     #+BEGIN_SRC emacs-lisp

     (defvar eos-tags-map
       (make-sparse-keymap)
       "Keymap for tags (navigation) keybinds.")

     (defvar eos-pm-map
       (make-sparse-keymap)
       "Keymap for project manager keybinds.")

     (defvar eos-sc-map
       (make-sparse-keymap)
       "Keymap for syntax check keybinds.")

     (defvar eos-complete-map
       (make-sparse-keymap)
       "Keymap for (complete) keybinds.")

     (defvar eos-window-map
       (make-sparse-keymap)
       "Keymap for window related keybinds.")

     (defvar eos-docs-map
       (make-sparse-keymap)
       "Keymap for documentation keybinds.")

     (defvar eos-rtags-map
       (make-sparse-keymap)
       "Keymap for rtag minor mode keybinds.")

     #+END_SRC

     Define maps as prefix commands.

     #+BEGIN_SRC emacs-lisp

     (dolist (prefix-map '(eos-tags-map
                           eos-pm-map
                           eos-sc-map
                           eos-docs-map
                           eos-window-map
                           eos-complete-map
                           eos-rtags-map))
       (define-prefix-command prefix-map))

     #+END_SRC

*** Functions
**** Funcall

     Funcall wrapper, if function is bounded, call it.

     #+BEGIN_SRC emacs-lisp

     (defun eos/funcall (func &optional args)
       "Call FUNC if it's bounded."
       (when (fboundp func)
         (funcall func args)))

     #+END_SRC

**** Build

     Tangle emacs-lisp source code blocks and byte-compile it.

     #+BEGIN_SRC emacs-lisp

     (defun eos/build ()
       "If the current buffer is '~/emacs.d/init.org' the code-blocks are
     tangled, and the tangled file is compiled."
       (interactive)
       (when (equal (buffer-name) "init.org")
         (progn
           ;; Avoid running hooks when tangling.
           (let ((prog-mode-hook nil))
             (org-babel-tangle)
             (byte-compile-file (concat user-emacs-directory "init.el"))))))

     #+END_SRC

**** Load

     Load file function, load the file if exists.

     #+BEGIN_SRC emacs-lisp

     (defun eos/load-file (file)
       "Load FILE if exists."
       (if (file-exists-p file)
           (load (expand-file-name file) t nil nil)))

     #+END_SRC

**** Debug

     Enable/Disable debug-on-error.

     #+BEGIN_SRC emacs-lisp

     (defun eos/toggle-debug-on-error ()
       "Toggle `debug-on-error`."
       (interactive)
       (customize-set-variable 'debug-on-error (not debug-on-error))
       (message "Debug-on-error: %s"
                (if debug-on-error "enabled" "disabled")))

     #+END_SRC

**** Buffer

     Buffer related functions.

     #+BEGIN_SRC emacs-lisp

     (defun eos/buffer-too-big-p ()
       "Return t if buffer-size if to big."
       (interactive)
       (or (> (buffer-size) (* 5000 80))
           (> (line-number-at-pos (point-max)) 5000)))

     #+END_SRC

**** Files

     Create a directory in the virtual file system, only if
     he does not exists.

     #+BEGIN_SRC emacs-lisp

     (defun eos/mkdir (dir)
       "Create DIR in the file system."
       ;; (interactive)
       (when (and (not (file-exists-p dir))
                  (make-directory dir :parents))))

     #+END_SRC

**** Compile

     Just a compile wrapper function.

     #+BEGIN_SRC emacs-lisp

     (defun eos/compile (dir command)
       "Compile COMMAND at specific DIR.
     Just a `compile` function wrapper."
       (interactive)
       (if (file-exists-p dir)
           (let ((default-directory dir))
             (compile command))))

     #+END_SRC

**** Move

     Movement related functions and keybinds.

     #+BEGIN_SRC emacs-lisp

     (defun eos/move/beginning-of-line (arg)
       "Move point back to indentation(ARG) start, or line(ARG) start."
       (interactive "^p")
       (setq arg (or arg 1))

       ;; Move lines first
       (when (/= arg 1)
         (let ((line-move-visual nil))
           (forward-line (1- arg))))

       (let ((orig-point (point)))
         (back-to-indentation)
         (when (= orig-point (point))
           (move-beginning-of-line 1))))

     #+END_SRC

***** Binds

      #+BEGIN_SRC emacs-lisp

      ;; line movement
      (global-set-key (kbd "C-a") 'eos/move/beginning-of-line)
      (global-set-key (kbd "C-e") 'move-end-of-line)

      ;; word movement
      (global-set-key (kbd "C-<left>") 'backward-word)
      (global-set-key (kbd "C-<right>") 'forward-whitespace)

      ;; scroll movement
      (global-set-key (kbd "C-M-v") 'scroll-other-window)
      (global-set-key (kbd "C-M-y") 'scroll-other-window-down)

      #+END_SRC

**** Edit

     Editing related functions and keybinds.

***** Move

      Move related functions.

      #+BEGIN_SRC emacs-lisp

      (defun eos/edit/move-lines (n)
        "Move N lines, up if N is positive, else down."
        (let* (text-start
               text-end
               (region-start (point))
               (region-end region-start)
               swap-point-mark
               delete-latest-newline)

          ;; STEP 1: identifying the text to cut.
          (when (region-active-p)
            (if (> (point) (mark))
                (setq region-start (mark))
              (exchange-point-and-mark)
              (setq swap-point-mark t
                    region-end (point))))

          ;; text-end and region-end
          (end-of-line)

          (if (< (point) (point-max))
              (forward-char 1)
            (setq delete-latest-newline t)
            (insert-char ?\n))
          (setq text-end (point)
                region-end (- region-end text-end))

          ;; text-start and region-start
          (goto-char region-start)
          (beginning-of-line)
          (setq text-start (point)
                region-start (- region-start text-end))

          ;; STEP 2: cut and paste.
          (let ((text (delete-and-extract-region text-start text-end)))
            (forward-line n)
            ;; If the current-column != 0, I have moved the region at the bottom of a
            ;; buffer doesn't have the trailing newline.
            (when (not (= (current-column) 0))
              (insert-char ?\n)
              (setq delete-latest-newline t))
            (insert text))

          ;; STEP 3: Restoring.
          (forward-char region-end)

          (when delete-latest-newline
            (save-excursion
              (goto-char (point-max))
              (delete-char -1)))

          (when (region-active-p)
            (setq deactivate-mark nil)
            (set-mark (+ (point) (- region-start region-end)))
            (if swap-point-mark
                (exchange-point-and-mark)))))

      (defun eos/edit/move-lines-up (n)
        "Move N lines up."
        (interactive "p")
        (if (eq n nil)
            (setq n 1))
        (eos/edit/move-lines (- n)))

      (defun eos/edit/move-lines-down (n)
        "Move N lines down."
        (interactive "p")
        (if (eq n nil)
            (setq n 1))
        (eos/edit/move-lines n))

      (defun eos/edit/move-words-left (n)
        "Move word N times to the left."
        (interactive "p")
        (if (eq n nil)
            (setq n 1))
        (transpose-words (- n)))

      #+END_SRC

***** Indent

      #+BEGIN_SRC emacs-lisp

      (defun eos/edit/indent-buffer ()
        "Indent the currently visited buffer."
        (interactive)
        (indent-region (point-min) (point-max)))

      (defun eos/edit/indent-region-or-buffer ()
        "Indent a region if selected, otherwise the whole buffer."
        (interactive)
        (save-excursion
          (if (region-active-p)
              (progn
                (indent-region (region-beginning) (region-end))
                (message "Indented selected region."))
            (progn
              (eos/edit/indent-buffer)
              (message "Indented buffer.")))))

      #+END_SRC

***** Duplicate

      #+BEGIN_SRC emacs-lisp

      (defun eos/edit/duplicate-current-line-or-region (arg)
        "Duplicates the current line or region ARG times.
        If there's no region, the current line will be duplicated.
        However, if there's a region, all lines that region covers will be duplicated."
        (interactive "p")
        (let (beg end (origin (point)))
          (if (and mark-active (> (point) (mark)))
              (exchange-point-and-mark))
          (setq beg (line-beginning-position))
          (if mark-active
              (exchange-point-and-mark))
          (setq end (line-end-position))
          (let ((region (buffer-substring-no-properties beg end))
                (i arg))
            (while (> i 0)
              (goto-char end)
              (newline)
              (insert region)
              (setq end (point))
              (setq i (1- i)))
            (goto-char (+ origin (* (length region) arg) arg)))))

      #+END_SRC

***** Binds

      #+BEGIN_SRC emacs-lisp

      ;; edit
      (global-set-key (kbd "M-i") 'eos/edit/indent-region-or-buffer)
      (global-set-key (kbd "M-j") 'eos/edit/duplicate-current-line-or-region)

      (global-set-key (kbd "M-p") 'eos/edit/move-lines-up)
      (global-set-key (kbd "M-n") 'eos/edit/move-lines-down)

      #+END_SRC

**** Kill

     Killing (buffers) related functions.

     #+BEGIN_SRC emacs-lisp

     (defun eos/kill-buffer (buffer-name)
       "Kill BUFFER-NAME if exists."
       (when (get-buffer buffer-name)
         (kill-buffer buffer-name)))

     (defun eos/kill/current-buffer ()
       "Kill the current buffer without prompting."
       (interactive)
       (kill-buffer (current-buffer)))

     #+END_SRC

**** Run

     Execute related functions.

     #+BEGIN_SRC emacs-lisp

     (defun eos/run/proc (name)
       "Run a process defined by NAME."
       (if (executable-find name)
           (start-process name nil name)
         nil))

     #+END_SRC

**** Misc

     Miscellaneous (auxiliary) useful functions.

     #+BEGIN_SRC emacs-lisp

     ;;; Get symbol at point, maybe
     (defun eos/get-selected-text-or-symbol-at-point ()
       "Get the text in region or symbol at point.

     If region is active, return the text in that region.  Else if the
     point is on a symbol, return that symbol name.  Else return nil."
       (cond ((use-region-p)
              (buffer-substring-no-properties (region-beginning) (region-end)))
             ((symbol-at-point)
              (substring-no-properties (thing-at-point 'symbol)))
             (t
              nil)))

     #+END_SRC

**** Font

     A safe set frame font function.

     #+BEGIN_SRC emacs-lisp

     (defun eos/set-frame-font (font)
       "Set the default font to FONT."
       (cond ((find-font (font-spec :name font))
              (set-frame-font font nil t))))

     #+END_SRC

** Vanilla
*** Cursor

    On a text terminal, the cursor's appearance is controlled by the
    terminal, largely out of the control of Emacs.
    Some terminals offer two different cursors: a visible static
    cursor, and a very visible blinking cursor.
    By default, Emacs uses the very visible cursor, and switches
    to it when you start or resume Emacs. If the variable
    visible-cursor is nil when Emacs starts or resumes, it uses
    the normal cursor.

    #+BEGIN_SRC emacs-lisp

    ;; non-nil means to make the cursor very visible
    (customize-set-variable 'visible-cursor nil)

    #+END_SRC

*** Window

    Emacs windows system.

    Characteristics:

    - Each Emacs window displays one Emacs buffer at any time.
    - A single buffer may appear in more than one window.
    - Emacs can split a frame into two or many windows.
    - Multiple frames always imply multiple windows, because each
      frame has its own set of windows.
    - Each window belongs to one and only one frame.

    Configure/customize windows standard/basic options,
    the description of each one can be found on the
    commentaries.

    #+BEGIN_SRC emacs-lisp

    ;; scroll options
    ;; number of lines of margin at the top and bottom of a window
    (customize-set-variable 'scroll-margin 0)

    ;; scroll up to this many lines, to bring point back on screen
    (customize-set-variable 'scroll-conservatively 100)

    ;; t means point keeps its screen position
    (customize-set-variable 'scroll-preserve-screen-position t)

    ;; non-nil means mouse commands use dialog boxes to ask questions
    (customize-set-variable 'use-dialog-box nil)

    ;; set window margins
    ;; width in columns of left marginal area for display of a buffer
    (customize-set-variable 'left-margin-width 1)

    ;; width in columns of right marginal area for display of a buffer.
    (customize-set-variable 'right-margin-width 1)

    ;; binds (global)
    (global-set-key (kbd "s-l") 'shrink-window-horizontally)
    (global-set-key (kbd "s-h") 'enlarge-window-horizontally)
    (global-set-key (kbd "s-j") 'shrink-window)
    (global-set-key (kbd "s-k") 'enlarge-window)

    ;; next and previous buffer (on current window)
    (define-key ctl-x-map (kbd "C-,") 'previous-buffer)
    (define-key ctl-x-map (kbd "C-.") 'next-buffer)

    ;; binds (eos-window prefix map)
    (define-key eos-window-map (kbd "1") 'maximize-window)
    (define-key eos-window-map (kbd "q") 'minimize-window)
    (define-key eos-window-map (kbd "w") 'balance-windows)

    ;; binds ctl-x-map (C-x w)
    (define-key ctl-x-map (kbd "w") 'eos-window-map)

    ;; kill buffer and window
    (define-key ctl-x-map (kbd "C-k") 'kill-buffer-and-window)

    #+END_SRC

**** The Zen of Buffer Display

     In its most simplistic form, a frame accommodates always
     one single window that can be used for displaying a buffer.
     As a consequence, it is always the latest call of display-buffer
     that will have succeeded in placing its buffer there.

     #+BEGIN_SRC emacs-lisp

     (add-to-list 'display-buffer-alist
                  '(("\\*Choices\\*"
                     (display-buffer-below-selected display-buffer-at-bottom)
                     (inhibit-same-window . t)
                     (window-height . fit-window-to-buffer))))

     #+END_SRC

*** Startup

    Customize/configure: ~startup.el~ related options.

    #+BEGIN_SRC emacs-lisp

    ;; custom
    ;; non-nil inhibits the startup screen.
    (customize-set-variable 'inhibit-startup-screen t)

    ;; non-nil inhibits the startup screen
    (customize-set-variable 'inhibit-startup-message t)

    ;; non-nil inhibits the initial startup echo area message
    (customize-set-variable 'inhibit-startup-echo-area-message t)

    #+END_SRC

*** Buffer

    Configure/customize standard/basic buffer options.

    #+BEGIN_SRC emacs-lisp

    ;; custom
    ;; non-nil means do not display continuation lines.
    (customize-set-variable 'truncate-lines nil)

    ;; sentences should be separated by a single space,
    ;; so treat two sentences as two when filling
    (customize-set-variable 'sentence-end-double-space nil)

    ;; default indent
    ;; distance between tab stops (for display of tab characters), in columns.
    (customize-set-variable 'tab-width 4)

    ;; indentation can insert tabs if this is non-nil.
    (customize-set-variable 'indent-tabs-mode nil)

    ;; kill process not confirmation required
    ;; list of functions called with no args to query before killing a buffer.
    ;; The buffer being killed will be current while the functions are running.
    (customize-set-variable
     'kill-buffer-query-functions
     (remq 'process-kill-buffer-query-function kill-buffer-query-functions))

    ;; non-nil means load prefers the newest version of a file.
    (customize-set-variable 'load-prefer-newer t)

    ;; hooks
    ;; (add-hook 'buffer-list-update-hook
    ;;           (lambda ()
    ;;             (if (eos/buffer-too-big-p)
    ;;                 (eos/funcall 'display-line-numbers 0))))

    #+END_SRC

*** Buffer-menu

    The Buffer Menu is used to view, edit, delete, or change attributes
    of buffers. The entry points are C-x C-b (`list-buffers') and
    M-x buffer-menu.

*** Minibuffer

    Minibuffer related options.

    #+BEGIN_SRC emacs-lisp

    ;; non-nil means to allow minibuffer commands while in the minibuffer
    (customize-set-variable 'enable-recursive-minibuffers t)

    #+END_SRC

*** Coding-system

    Configure/set coding-system (UTF8), everywhere!

    #+BEGIN_SRC emacs-lisp

    ;; coding system to use with system messages
    (customize-set-variable 'locale-coding-system 'utf-8)

    ;; coding system to be used for encoding the buffer contents on saving
    (customize-set-variable 'buffer-file-coding-system 'utf-8)

    ;; add coding-system at the front of the priority list for automatic detection
    (prefer-coding-system 'utf-8)

    ;; set coding system (UFT8)
    (set-language-environment "UTF-8")
    (set-terminal-coding-system 'utf-8)
    (set-keyboard-coding-system 'utf-8)
    (set-selection-coding-system 'utf-8)

    #+END_SRC

*** Simple

    A grab-bag of basic Emacs commands not specifically related to
    some major mode or to file-handling.

    #+BEGIN_SRC emacs-lisp

    (when (require 'simple nil t)
      (progn
        ;; custom
        ;; don't omit information when lists nest too deep.
        (customize-set-variable 'eval-expression-print-level nil)

        ;; binds
        (define-key ctl-x-map (kbd "C-g") 'keyboard-quit)

        ;; enable
        ;; column number display in the mode line
        (eos/funcall 'column-number-mode 1)

        ;; buffer size display in the mode line
        (eos/funcall 'size-indication-mode 1)))

    #+END_SRC

*** Prog-mode

    Generic programming mode, from which others derive.

    #+BEGIN_SRC emacs-lisp

    (require 'prog-mode nil t)

    #+END_SRC

*** Server

    Allow this Emacs process to be a server for client processes.
    This starts a server communications subprocess through which
    client "editors" can send your editing commands to this
    Emacs job. To use the server, set up the program emacsclient
    in the Emacs distribution as your standard "editor".

    #+BEGIN_SRC emacs-lisp

    (when (require 'server nil t)
      (progn
        ;; hooks
        ;; enable emacs server after startup
        (add-hook 'emacs-startup-hook
                  (lambda ()
                    (eos/funcall 'server-start)))))

    #+END_SRC

*** Help
**** Help

     GNU Emacs's built-in help system, the one invoked by
     M-x help-for-help.

     #+BEGIN_SRC emacs-lisp

     (when (require 'help nil t)
       (progn
         ;; custom
         ;; always select the help window
         (customize-set-variable 'help-window-select t)))

     ;; binds
     (when (boundp 'help-map)
       (progn
         ;; clean, quality of life
         (define-key help-map (kbd "<help>") nil)
         (define-key help-map (kbd "<f1>") nil)
         (define-key help-map (kbd "C-n") nil)
         (define-key help-map (kbd "C-h") nil)
         (define-key help-map (kbd "C-;") nil)
         (define-key help-map (kbd "K") nil)
         (define-key help-map (kbd "RET") nil)))

     #+END_SRC

**** Help-mode

     Help-mode, which is the mode used by *Help* buffers, and
     associated support machinery, such as adding hyperlinks, etc...

     #+BEGIN_SRC emacs-lisp

     (require 'help-mode nil t)

     ;; binds
     (when (boundp 'help-mode-map)
       (progn
         (define-key help-mode-map (kbd "C-j") 'push-button)))

     #+END_SRC

*** Info

    The GNU Project distributes most of its manuals in the Info format,
    which you read using an Info reader.

    #+BEGIN_SRC emacs-lisp

    (when (require 'info nil t)
      (progn
        ;; custom
        ;; non-nil means don’t record intermediate Info nodes to the history
        (customize-set-variable 'info-history-skip-intermediate-nodes nil)

        ;; 0 means do not display breadcrumbs
        ;; (customize-set-variable 'info-breadcrumbs-depth 0)
        ))

    #+END_SRC

*** Fringe

    Contains code to initialize the built-in fringe bitmaps
    as well as helpful functions for customizing the appearance of the
    fringe.

    #+BEGIN_SRC emacs-lisp

    (when (require 'fringe nil t)
      (progn
        ;; disable
        (add-hook 'after-init-hook
                  (lambda ()
                    ;; set the default appearance of fringes on the selected frame
                    ;; 1 ->  ("no-fringes" . 0)
                    (set-fringe-style 1)))))

    #+END_SRC

*** Files

    Defines most of Emacs's file- and directory-handling functions,
    including basic file visiting, backup generation, link handling,
    ITS-id version control, load- and write-hook handling, and the like.

    #+BEGIN_SRC emacs-lisp

    (when (require 'files nil t)
      (progn
        ;; custom
        ;; control use of version numbers for backup files.
        (customize-set-variable 'version-control t)

        ;; non-nil means always use copying to create backup files
        (customize-set-variable 'backup-by-copying t)

        ;; number of newest versions to keep when a new numbered backup is made
        (customize-set-variable 'kept-new-versions 6)

        ;; number of oldest versions to keep when a new numbered backup is made
        (customize-set-variable 'kept-old-versions 2)

        ;; if t, delete excess backup versions silently
        (customize-set-variable 'delete-old-versions t)

        ;; non-nil means make a backup of a file the first time it is saved
        (customize-set-variable 'make-backup-files nil)

        ;; non-nil says by default do auto-saving of every file-visiting buffer
        (customize-set-variable 'auto-save-default nil)

        ;; most *NIX tools work best when files are terminated
        ;; with a newline
        (customize-set-variable 'require-final-newline t)

        ;; backup directory list
        ;; alist of filename patterns and backup directory names
        ;; TODO: remove the hardcoded path and use user-emacs-directory
        (customize-set-variable 'backup-directory-alist '(("" . "~/.emacs.d/backup")))))

    ;; create cache directory
    (eos/mkdir (concat user-emacs-directory "cache"))

    #+END_SRC

*** Recentf

    The recent files list is automatically saved across Emacs
    sessions. You can customize the number of recent files displayed,
    the location of the menu and others options
    (see the source code for details).

    #+BEGIN_SRC emacs-lisp

    (when (require 'recentf nil t)
      (progn
        ;; custom
        ;; file to save the recent list into.
        (customize-set-variable
         'recentf-save-file (concat user-emacs-directory "cache/recentf"))))

    #+END_SRC

*** Bookmark

    The bookmark list is sorted lexically by default, but you can turn
    this off by setting bookmark-sort-flag to nil. If it is nil, then
    the list will be presented in the order it is recorded
    (chronologically), which is actually fairly useful as well.

    #+BEGIN_SRC emacs-lisp

    (when (require 'bookmark nil t)
      (progn
        ;; custom
        ;; file in which to save bookmarks by default.
        (customize-set-variable
         'bookmark-default-file (concat user-emacs-directory "cache/bookmarks"))))

    #+END_SRC

*** Savehist

    Many editors (e.g. Vim) have the feature of saving minibuffer
    history to an external file after exit.  This package provides the
    same feature in Emacs.  When set up, it saves recorded minibuffer
    histories to a file (`~/.emacs-history' by default).  Additional
    variables may be specified by customizing
    `savehist-additional-variables'.

    #+BEGIN_SRC emacs-lisp

    (when (require 'savehist nil t)
      (progn
        ;; file name where minibuffer history is saved to and loaded from.
        (customize-set-variable
         'savehist-file (concat user-emacs-directory "cache/history"))

        ;; if non-nil, save all recorded minibuffer histories.
        (customize-set-variable 'savehist-save-minibuffer-history t)

        ;; enable savehist mode
        (eos/funcall 'savehist-mode 1)))

    #+END_SRC

*** Frame

    When Emacs is started on a graphical display, e.g., on the X Window
    System, it occupies a graphical system-level display region.  In this
    manual, we call this a “frame”, reserving the word “window” for the part
    of the frame used for displaying a buffer.

    - A frame initially contains one window, but it can be subdivided
      into multiple windows

    Configure/customize frame related options:

    #+BEGIN_SRC emacs-lisp

    (when (require 'frame nil t)
      (progn
        ;; custom
        ;; with some window managers you may have to set this to non-nil
        ;; in order to set the size of a frame in pixels, to maximize
        ;; frames or to make them fullscreen.
        (customize-set-variable 'frame-resize-pixelwise t)

        ;; normalize before maximize
        (customize-set-variable 'x-frame-normalize-before-maximize t)

        ;; set frame title format
        (customize-set-variable 'frame-title-format
                                '((:eval (if (buffer-file-name)
                                             (abbreviate-file-name (buffer-file-name))
                                           "%b"))))

        ;; alist of parameters for the initial X window frame
        (add-to-list 'initial-frame-alist '(fullscreen . fullheight))

        ;; (vertical-scroll-bars)
        ;; (bottom-divider-width . 0)
        ;; (right-divider-width . 6)))

        ;; alist of default values for frame creation
        (add-to-list 'default-frame-alist '(internal-border-width . 2))

        ;; set frame font
        (eos/set-frame-font "Hermit Light:pixelsize=18")

        ;; hooks
        ;; enable window divider
        (add-hook 'after-init-hook
                  (lambda()
                    (eos/funcall 'window-divider-mode)))

        ;; disable blink cursor
        (add-hook 'emacs-startup-hook
                  (lambda()
                    (eos/funcall 'blink-cursor-mode 0)))))

    ;; binds
    (global-set-key (kbd "s-o") 'other-frame)

    ;; set font by face attribute (reference)
    ;; (set-face-attribute 'default nil :height)

    #+END_SRC

*** Windmove

    This package defines a set of routines, windmove-{left,up,right,
    down}, for selection of windows in a frame geometrically.
    For example, `windmove-right' selects the window immediately to the
    right of the currently-selected one.

    #+BEGIN_SRC emacs-lisp

    (when (require 'windmove nil t)
      (progn
        ;; enable
        ;; window move default keybinds (shift-up/down etc..)
        (eos/funcall 'windmove-default-keybindings)))

    ;; binds, eos-window-map (window prefix map)
    ;; (define-key eos-window-map (kbd "j") 'windmove-up)
    ;; (define-key eos-window-map (kbd "k") 'windmove-down)
    ;; (define-key eos-window-map (kbd "h") 'windmove-left)
    ;; (define-key eos-window-map (kbd "l") 'windmove-right)

    #+END_SRC

*** Kmacro

    The kmacro package provides the user interface to emacs' basic
    keyboard macro functionality.  With kmacro, two function keys are
    dedicated to keyboard macros, by default F3 and F4.

    #+BEGIN_SRC emacs-lisp

    (when (require 'kmacro nil t)
      (progn
        ;; binds
        (define-key ctl-x-map (kbd "m") 'kmacro-keymap)))

    #+END_SRC

*** Paren

    It will display highlighting on whatever paren matches the one
    before or after point.

    #+BEGIN_SRC emacs-lisp

    (require 'paren nil t)

    ;; enable
    ;; visualization of matching parens
    (eos/funcall 'show-paren-mode 1)

    #+END_SRC

*** Hideshow

    Minor mode to hide and show code and comment blocks.

    #+BEGIN_SRC emacs-lisp

    (when (require 'hideshow nil t)
      (progn
        ;; hooks
        (add-hook 'prog-mode-hook 'hs-minor-mode)

        ;; binds
        (define-key ctl-x-map (kbd "[") 'hs-toggle-hiding)))

    #+END_SRC

*** Elec-pair

    Electric pairing: automatically matches parenthesis pairs,
    should be enabled regardless the current major mode.

    #+BEGIN_SRC emacs-lisp

    (when (require 'elec-pair nil t)
      (progn
        ;; custom
        ;; alist of pairs that should be used regardless of major mode.
        (customize-set-variable 'electric-pair-pairs
                                '((?\{ . ?\})
                                  (?\( . ?\))
                                  (?\[ . ?\])
                                  (?\" . ?\")))

        ;; enable
        (eos/funcall 'electric-pair-mode 1)))

    #+END_SRC

*** Newcomment

    This library contains functions and variables for commenting and
    uncommenting source code.

    #+BEGIN_SRC emacs-lisp

    (when (require 'newcomment nil t)
      (progn
        ;; binds
        (global-set-key (kbd "M-c") 'comment-or-uncomment-region)))

    #+END_SRC

*** Time

    Facilities to display current time/date and a new-mail indicator
    in the Emacs mode line.

    #+BEGIN_SRC emacs-lisp

    (when (require 'time nil t)
      (progn
        ;; custom
        ;; seconds between updates of time in the mode line.
        (customize-set-variable 'display-time-interval 15)

        ;; non-nil indicates time should be displayed as hh:mm, 0 <= hh <= 23
        (customize-set-variable 'display-time-24hr-format t)

        ;; set format time string
        (customize-set-variable 'display-time-format "%H:%M")

        ;; load-average values below this value won’t be shown in the mode line.
        (customize-set-variable 'display-time-load-average-threshold 1.0)

        ;; enable display time
        (eos/funcall 'display-time-mode 1)))

    #+END_SRC

*** Tool-bar

    Provides `tool-bar-mode' to control display of the tool-bar and
    bindings for the global tool bar with convenience functions
    `tool-bar-add-item' and `tool-bar-add-item-from-menu'.

    Tool bar in all graphical frames disabled by default.

    #+BEGIN_SRC emacs-lisp

    (when (require 'tool-bar nil t)
      (progn
        ;; disable
        (eos/funcall 'tool-bar-mode 0)))

    #+END_SRC

*** Tooltip

    When this global minor mode is enabled, Emacs displays help
    text (e.g. for buttons and menu items that you put the mouse on)
    in a pop-up window.

    Disabled by default.

    #+BEGIN_SRC emacs-lisp

    (when (require 'tooltip nil t)
      (progn
        ;; disable tooltip
        (eos/funcall 'tooltip-mode 0)))

    #+END_SRC

*** Menu-bar

    Each Emacs frame normally has a "menu bar" at the top which you can use
    to perform common operations. There's no need to list them here, as you
    can more easily see them yourself.

    Disabled by default.

    #+BEGIN_SRC emacs-lisp

    (when (require 'menu-bar nil t)
      (progn
        ;; disable menu-bar
        (eos/funcall 'menu-bar-mode 0)))

    #+END_SRC

*** Scroll-bar

    Specify whether to have vertical scroll bars, and on which side.
    Disabled by default.

    #+BEGIN_SRC emacs-lisp

    (when (require 'scroll-bar nil t)
      (progn
        ;; disable scroll bar
        (eos/funcall 'scroll-bar-mode 0)))

    #+END_SRC

*** Hl-line

    Provides a local minor mode (toggled by M-x hl-line-mode) and
    a global minor mode (toggled by M-x global-hl-line-mode) to
    highlight, on a suitable terminal, the line on which point is.

    #+BEGIN_SRC emacs-lisp

    (when (require 'hl-line nil t)
      (progn
        ;; enable highlight line
        (eos/funcall 'global-hl-line-mode 1)))

    #+END_SRC

*** Linum

    Display line numbers for the current buffer.

    #+BEGIN_SRC emacs-lisp

    (when (require 'linum nil t)
      (progn
        ;; custom
        ;; format used to display line numbers.
        (customize-set-variable 'linum-format " %2d ")))

    #+END_SRC

*** Display-line-numbers

    Display line numbers in the buffer.
    Provides a minor mode interface for `display-line-numbers'.

    #+BEGIN_SRC emacs-lisp

    (when (require 'display-line-numbers nil t)
      (progn
        ;; hooks
        ;; (add-hook 'prog-mode-hook 'display-line-numbers-mode)

        ;; enable display line numbers mode
        (eos/funcall 'global-display-line-numbers-mode 1)))

    #+END_SRC

*** Delsel

    This package makes the active region be pending delete, meaning that
    text inserted while the region is active will replace the region contents.
    This is a popular behavior of personal computers text editors.

    #+BEGIN_SRC emacs-lisp

    (when (require 'delsel nil t)
      (progn
        ;; delete selection-mode
        (eos/funcall 'delete-selection-mode 1)))

    #+END_SRC

*** Whitespace

    This package is a minor mode to visualize and clean
    blanks (TAB, (HARD) SPACE and NEWLINE).

    #+BEGIN_SRC emacs-lisp

    (when (require 'whitespace nil t)
      (progn
        ;; hooks
        ;; clean whitespace and newlines before buffer save
        (add-hook 'before-save-hook 'whitespace-cleanup)

        ;; binds
        (define-key ctl-x-map (kbd ".") 'whitespace-mode)))

    #+END_SRC

*** Subword

    This package provides the `subword' minor mode, which merges the
    old remap-based subword.el (derived from cc-mode code) and
    cap-words.el, which takes advantage of core Emacs
    word-motion-customization functionality.

    #+BEGIN_SRC emacs-lisp

    (when (require 'subword nil t)
      (progn
        ;; enable
        (eos/funcall 'global-subword-mode 1)))

    #+END_SRC

*** Face-remap

    This package defines some simple operations that can be used for
    maintaining the `face-remapping-alist' in a cooperative way.
    This is especially important for the `default' face.

    #+BEGIN_SRC emacs-lisp

    (when (require 'face-remap nil t)
      (progn
        ;; binds
        ;; text scale adjust
        (define-key ctl-x-map (kbd "=") 'text-scale-adjust)))

    #+END_SRC

*** Custom

    Emacs has many settings which you can change. Most settings are
    customizable variables, which are also called user options.
    There is a huge number of customizable variables,
    controlling numerous aspects of Emacs behavior.

    #+BEGIN_SRC emacs-lisp

    (when (require 'custom nil t)
      (progn
        ;; custom
        ;; file used for storing customization information.
        ;; The default is nil, which means to use your init file
        ;; as specified by ‘user-init-file’.  If the value is not nil,
        ;; it should be an absolute file name.
        (customize-set-variable
         'custom-file (concat (expand-file-name user-emacs-directory) "custom.el"))))

    ;; load custom-file
    (eos/load-file custom-file)

    #+END_SRC

*** Forms

    Forms mode means visiting a data file which is supposed to consist
    of records each containing a number of fields. The records are
    separated by a newline, the fields are separated by a user-defined
    field separator (default: TAB). When shown, a record is
    transferred to an Emacs buffer and presented using a user-defined
    form. One record is shown at a time.

    #+BEGIN_SRC emacs-lisp

    (require 'forms nil t)

    #+END_SRC

** Applications
*** Package Management
**** Cask

     Cask is a project management tool fo Emacs that helps
     automate the package development cycle; development,
     dependencies, testing, building, packaging and more.

     Cask can also be used to manage dependencies for your local
     Emacs configuration.

     I do prefer cask over packages.el, because the management
     of third party packages can be done outside of emacs,
     provinding more control and flexibility.

     #+BEGIN_SRC emacs-lisp

     ;; avoid warnings when byte-compile
     (eval-when-compile
       ;; eval require when compile
       (require 'cask "~/.cask/cask.el" t)

       ;; enable
       (if (fboundp 'cask-initialize)
           (cask-initialize)))

     ;; load cask
     (require 'cask "~/.cask/cask.el" t)

     ;; initialize cask
     (eos/funcall 'cask-initialize)

     #+END_SRC

*** X
**** Exwm

     EXWM (Emacs X Window Manager) is a full-featured tiling X window manager
     for Emacs built on top of [XELB].

     #+BEGIN_SRC emacs-lisp

     (when (require 'exwm nil t)
       (progn
         (require 'exwm-config nil t)

         ;; set exwm workspaces number
         (customize-set-variable 'exwm-workspace-number 0)

         ;; show workspaces in all buffers
         (customize-set-variable 'exwm-workspace-show-all-buffers t)

         ;; non-nil to allow switching to buffers on other workspaces
         (customize-set-variable 'exwm-layout-show-all-buffers t)

         ;; non-nil to force managing all X windows in tiling layout.
         (customize-set-variable 'exwm-manage-force-tiling t)

         ;; exwn global keybindings
         (customize-set-variable 'exwm-input-global-keys
                                 `(([?\s-r] . exwm-reset)
                                   ([?\s-q] . exwm-input-toggle-keyboard)
                                   ;; ([?\s-w] . exwm-workspace-switch)
                                   ;; ([?\s-k] . exwm-workspace-delete)
                                   ;; ([?\s-a] . exwm-workspace-swap)

                                   ;; create and switch to workspaces
                                   ,@(mapcar (lambda (i)
                                               `(,(kbd (format "s-%d" i)) .
                                                 (lambda ()
                                                   (interactive)
                                                   (exwm-workspace-switch-create ,i))))
                                             (number-sequence 0))))

         ;; The following example demonstrates how to use simulation keys to mimic
         ;; the behavior of Emacs.  The value of `exwm-input-simulation-keys` is a
         ;; list of cons cells (SRC . DEST), where SRC is the key sequence you press
         ;; and DEST is what EXWM actually sends to application.  Note that both SRC
         ;; and DEST should be key sequences (vector or string).
         (customize-set-variable 'exwm-input-simulation-keys
                                 '(
                                   ;; movement
                                   ([?\C-b] . [left])
                                   ([?\M-b] . [C-left])
                                   ([?\C-f] . [right])
                                   ([?\M-f] . [C-right])
                                   ([?\C-p] . [up])
                                   ([?\C-n] . [down])
                                   ([?\C-a] . [home])
                                   ([?\C-e] . [end])
                                   ([?\M-v] . [prior])
                                   ([?\C-v] . [next])
                                   ([?\C-d] . [delete])
                                   ([?\C-k] . [S-end delete])

                                   ;; firefox temporary
                                   ([?\C-o] . [C-prior]) ; change tab mapping
                                   ([?\C-k] . [C-w]) ; close tab mapping
                                   ([?\C-j] . [return]) ; close tab mapping

                                   ;; cut/paste.
                                   ([?\C-w] . [?\C-x])
                                   ([?\M-w] . [?\C-c])
                                   ([?\C-y] . [?\C-v])

                                   ;; Escape (cancel)
                                   ([?\C-g] . [escape])

                                   ;; search
                                   ([?\C-s] . [?\C-f])))))

     ;; this little bit will make sure that XF86 keys work in exwm buffers as well
     (if (boundp 'exwm-input-prefix-keys)
         (progn
           (dolist (key '(XF86AudioLowerVolume
                          XF86AudioRaiseVolume
                          XF86PowerOff
                          XF86AudioMute
                          XF86AudioPlay
                          XF86AudioStop
                          XF86AudioPrev
                          XF86AudioNext
                          XF86ScreenSaver
                          XF68Back
                          XF86Forward
                          Scroll_Lock
                          print))
             (cl-pushnew key exwm-input-prefix-keys))))

     ;; enable exwm
     (eos/funcall 'exwm-enable)

     ;; All buffers created in EXWM mode are named "*EXWM*". You may want to
     ;; change it in `exwm-update-class-hook' and `exwm-update-title-hook', which
     ;; are run when a new X window class name or title is available.  Here's
     ;; some advice on this topic:
     ;; + Always use `exwm-workspace-rename-buffer` to avoid naming conflict.
     ;; + For applications with multiple windows (e.g. GIMP), the class names of
     ;; all windows are probably the same.  Using window titles for them makes
     ;; more sense.
     (require 'exwm-core nil t)
     (require 'exwm-workspace nil t)

     ;; hooks
     ;; update the buffer name by X11 window title
     (add-hook 'exwm-update-title-hook
               (lambda ()
                 (exwm-workspace-rename-buffer
                  (concat "[" exwm-class-name "] " exwm-title))))

     #+END_SRC

**** Exwm-randr

     This module adds Randr support for EXWM.
     Currently it requires external tools such as xrandr(1)
     to properly configure Randr first.

     #+BEGIN_SRC emacs-lisp

     (when (require 'exwm-randr nil t)
       (progn
         ;; custom
         ;; monitors: check the xrandr(1) output and use the same name/order
         ;; TODO: create a func that retrieves these values from xrandr
         ;; (customize-set-variable
         ;;  'exwm-randr-workspace-monitor-plist '(0 "eDP-1"
         ;;                                        1 "HDMI-1"))

         (customize-set-variable 'exwm-workspace-number
                                 (if (boundp 'exwm-randr-workspace-monitor-plist)
                                     (progn
                                       (/ (safe-length exwm-randr-workspace-monitor-plist) 2))
                                   1))))

     ;; enable
     ;; (exwm-randr-enable)

     #+END_SRC

**** Helm-exwm

     #+BEGIN_SRC emacs-lisp

     (defvar eos/helm-source-exwm-buffers
       nil
       "Helm exwm buffers source.")

     (when (require 'helm-exwm nil t)
       (progn
         ;; exwm buffers list
         (setq eos/helm-source-exwm-buffers
               (if (fboundp 'helm-exwm-build-source)
                   (helm-exwm-build-source)))))

     #+END_SRC

*** Process
**** Async

     Adds the ability to call asynchronous functions and process with
     ease. See the documentation for `async-start' and `async-start-process'.

     #+BEGIN_SRC emacs-lisp

     (require 'async nil t)
     (require 'async-bytecomp nil t)

     ;; to run command without displaying the output in a window
     (add-to-list 'display-buffer-alist
                  '("\\*Async Shell Command\\*" display-buffer-no-window))

     #+END_SRC

*** Window
**** Buffer-move

     #+BEGIN_SRC emacs-lisp

     (when (require 'buffer-move nil t)
       (progn
         ;; bind
         (global-set-key (kbd "C-s-j") 'buf-move-up)
         (global-set-key (kbd "C-s-k") 'buf-move-down)
         (global-set-key (kbd "C-s-h") 'buf-move-left)
         (global-set-key (kbd "C-s-l") 'buf-move-right)))

     #+END_SRC

*** Selector

    or to be more precise: Fuzzy Matching Engine (Helm)!

**** Helm

     Helm is an Emacs framework for incremental completions and
     narrowing selections. It provides an easy-to-use API for
     developers wishing to build their own Helm applications in
     Emacs, powerful search tools and dozens of already built-in
     commands providing completion to almost everything.

     #+BEGIN_SRC emacs-lisp

     (when (require 'helm nil t)
       (progn
         ;; require
         (require 'helm-config nil t)

         ;; custom
         ;; idle time before updating, specified in seconds (variable defined as float)
         (customize-set-variable 'helm-input-idle-delay 0.01)

         ;; set autoresize max and mim height
         (customize-set-variable 'helm-autoresize-max-height 30)
         (customize-set-variable 'helm-autoresize-min-height 15)

         ;; enable fuzzing matching
         (customize-set-variable 'helm-M-x-fuzzy-match t)
         (customize-set-variable 'helm-imenu-fuzzy-match t)
         (customize-set-variable 'helm-recentf-fuzzy-match t)
         (customize-set-variable 'helm-apropos-fuzzy-match t)
         (customize-set-variable 'helm-lisp-fuzzy-completion t)
         (customize-set-variable 'helm-buffers-fuzzy-matching t)

         ;; helm-M-x save command in extended-command-history even when it fail
         (customize-set-variable 'helm-M-x-always-save-history t)

         ;; always show details in buffer list when non-nil
         (customize-set-variable 'helm-buffer-details-flag t)

         ;; forces split inside selected window when non-nil
         (customize-set-variable 'helm-split-window-inside-p t)

         ;; cycle to the beginning or end of the list after reaching the bottom or top
         (customize-set-variable 'helm-move-to-line-cycle-in-source t)

         ;; scroll amount when scrolling other window in a helm session.
         (customize-set-variable 'helm-scroll-amount 8)

         ;; send current input in header-line when non-nil
         (customize-set-variable 'helm-echo-input-in-header-line t)

         ;; search for library in 'require' and 'declare-function' sexp.
         (customize-set-variable 'helm-ff-search-library-in-sexp t)

         ;; use 'recentf-list' instead of 'file-name-history' in 'helm-find-files'.
         (customize-set-variable 'helm-ff-file-name-history-use-recentf t)

         ;; this enable support for completing-read-multiple
         ;; and completion-at-point when non--nil
         (customize-set-variable 'helm-mode-handle-completion-in-region t)

         ;; if non-nil, prevent escaping from minibuffer with other-window
         ;; during the helm sessions
         (customize-set-variable 'helm-prevent-escaping-from-minibuffer t)

         ;; display header-line when non nil.
         (customize-set-variable 'helm-display-header-line nil)

         ;; binds (C-x)
         ;; (define-key ctl-x-map (kbd "b") 'helm-buffers-list)
         (define-key ctl-x-map (kbd "C-b") 'helm-mini)
         (define-key ctl-x-map (kbd "C-f") 'helm-find-files)
         (define-key ctl-x-map (kbd "c") 'helm-command-prefix)

         ;; binds (C-h) help
         (define-key help-map (kbd "a") 'helm-apropos)

         ;; binds (global)
         (global-set-key (kbd "M-x") 'helm-M-x)
         (global-set-key (kbd "M-y") 'helm-show-kill-ring)
         (global-set-key (kbd "M-m") 'helm-mark-ring)))

     ;; enable
     (eos/funcall 'helm-mode 1)
     (eos/funcall 'helm-autoresize-mode 1)

     ;; binds
     (when (boundp 'helm-map)
       (progn
         (define-key helm-map (kbd "TAB") 'helm-execute-persistent-action)
         (define-key helm-map (kbd "C-j") 'helm-maybe-exit-minibuffer)
         (define-key helm-map (kbd "C-z") 'helm-select-action)))

     #+END_SRC

**** Helm-lib

     All helm functions that don't require specific helm code
     are defined in helm-lib package.

     #+BEGIN_SRC emacs-lisp

     (when (require 'helm-lib nil t)
       (progn
         ;; custom
         ;; display help window in full frame when non nil
         (customize-set-variable 'helm-help-full-frame t)))

     #+END_SRC

**** Helm-source

     #+BEGIN_SRC emacs-lisp

     ;; for some silency (byte-compile)
     (defvar helm-mini-default-sources nil "")

     (when (require 'helm-source nil t)
       (progn
         ;; files buffers list
         (defvar eos/helm-source-file-buffers
           (if (fboundp 'helm-make-source)
               (helm-make-source "File Buffers" 'helm-source-in-buffer
                 :data 'helm-buffer-list
                 :candidate-transformer (lambda (buffers)
                                          (cl-loop for buf in buffers
                                                   when (with-current-buffer
                                                            buf buffer-file-name)
                                                   collect buf))
                 :action 'helm-type-buffer-actions))
           "Helm file buffers source.")

         ;; non files buffers list
         (defvar eos/helm-source-nonfile-buffers
           (if (fboundp 'helm-make-source)
               (helm-make-source "Non-file Buffers" 'helm-source-in-buffer
                 :data 'helm-buffer-list
                 :candidate-transformer (lambda (buffers)
                                          (cl-loop for buf in buffers
                                                   unless (with-current-buffer
                                                              buf buffer-file-name)
                                                   collect buf))
                 :filtered-candidate-transformer 'helm-skip-boring-buffers
                 :action 'helm-type-buffer-actions))
           "Helm nonfile buffers source.")

         ;; setq helm-mini default sources
         (setq helm-mini-default-sources
               '(eos/helm-source-file-buffers
                 eos/helm-source-exwm-buffers
                 helm-source-buffers-list
                 helm-source-recentf
                 ;; eos/helm-source-nonfile-buffers
                 helm-source-buffer-not-found))))

     #+END_SRC

*** Apparence
**** Theme
***** Mesk-term

      Add theme directory to load-path and load the
      default theme.

      #+BEGIN_SRC emacs-lisp

      ;; add eos-theme-dir to theme load path
      (add-to-list 'custom-theme-load-path
                   (concat user-emacs-directory "themes"))

      ;; load theme
      (load-theme 'mesk-term t)

      #+END_SRC

**** All-the-icons

     #+BEGIN_SRC emacs-lisp

     (when (require 'all-the-icons nil t)
       (progn
         ;; custom
         ;; whether or not to include a foreground colour when formatting the icon
         (customize-set-variable 'all-the-icons-color-icons nil)

         ;; the default adjustment to be made to the `raise' display property of an icon
         (customize-set-variable 'all-the-icons-default-adjust -0.0)

         ;; the base Scale Factor for the `height' face property of an icon
         (customize-set-variable 'all-the-icons-scale-factor 1.0)))

     #+END_SRC

*** Session
**** Desktop
*** Security
**** Encryption
***** Epa

      EasyPG is an all-in-one GnuPG interface for Emacs.
      It has two aspects: convenient tools which allow to use GnuPG
      from Emacs (EasyPG Assistant), and a fully
      functional interface library to GnuPG (EasyPG Library).

      #+BEGIN_SRC emacs-lisp

      (when (require 'epa nil t)
        (progn
          ;; custom
          ;; if non-nil, cache passphrase for symmetric encryption.
          (customize-set-variable
           'epa-file-cache-passphrase-for-symmetric-encryption t)

          ;; if t, always asks user to select recipients.
          (customize-set-variable 'epa-file-select-keys nil)

          ;; the gpg executable.
          (customize-set-variable 'epg-gpg-program "gpg")

          ;; the pinentry mode.
          ;; In epa commands, a particularly useful mode is ‘loopback’, which
          ;; redirects all Pinentry queries to the caller, so Emacs can query
          ;; passphrase through the minibuffer, instead of external Pinentry
          ;; program.
          (customize-set-variable 'epa-pinentry-mode 'loopback)))

      #+END_SRC

**** Authentication
***** Auth-source

      It lets users tell Gnus how to authenticate in a single place.
      Simplicity is the goal. Instead of providing 5000 options,
      we'll stick to simple, easy to understand options.

      #+BEGIN_SRC emacs-lisp

      (when (require 'auth-source nil t)
        (progn

          ;; Note: If the auth-sources variable contains ~/.auth.gpg before
          ;; ~/.auth, the auth-source library will try to read the GnuPG
          ;; encrypted .gpg file first, before the unencrypted file.

          ;; list of authentication sources
          (customize-set-variable
           'auth-sources '("~/.auth/auth.gpg" "~/.auth/netrc"))))

      #+END_SRC

**** Password
***** Password-store

      #+BEGIN_SRC emacs-lisp

      (require 'password-store nil t)

      #+END_SRC

**** Utils

     #+BEGIN_SRC emacs-lisp

     (defun eos/lookup-password (host user port)
       "Lookup password on auth-source default file."
       (let ((auth (auth-source-search :host host :user user :port port)))
         (if auth
             (let ((secretf (plist-get (car auth) :secret)))
               (if secretf
                   (funcall secretf)
                 (error "Auth entry for %s@%s:%s has no secret!"
                        user host port)))
           (error "No auth entry found for %s@%s:%s" user host port))))

     #+END_SRC

*** Help
**** Helm-info

     Browse info index with Helm.

     #+BEGIN_SRC emacs-lisp

     (when (require 'helm-info nil t)
       (progn
         ;; binds
         (if (boundp 'helm-map)
             (progn
               (define-key help-map (kbd "C-i") 'helm-info)))))

     #+END_SRC

**** Helm-descbinds

     This package is a replacement of `describe-bindings' for Helm.

     #+BEGIN_SRC emacs-lisp

     (when (require 'helm-descbinds nil t)
       (progn
         ;; helm-descbinds, window splitting style (2: vertical)
         (customize-set-variable 'helm-descbinds-window-style 2)

         ;; binds
         ;; help-map (C-h)
         (if (boundp 'help-map)
             (progn
               ;; (define-key help-map (kbd "b") 'helm-descbinds)
               (define-key help-map (kbd "C-b") 'helm-descbinds)))))

     #+END_SRC

*** Edit
**** Iedit

     #+BEGIN_SRC emacs-lisp

     (when (require 'iedit nil t)
       (progn
         ;; if no-nil, the key is inserted into global-map,
         ;; isearch-mode-map, esc-map and help-map.
         (customize-set-variable 'iedit-toggle-key-default nil)))

     ;; binds
     (when (boundp 'iedit-mode-keymap)
       (define-key iedit-mode-keymap (kbd "TAB") 'eos/complete-or-indent))

     #+END_SRC

**** Undo-tree

     #+BEGIN_SRC emacs-lisp

     (when (require 'undo-tree nil t)
       (progn
         ;; define alias for redo
         (defalias 'redo 'undo-tree-redo)

         ;; binds
         (define-key ctl-x-map (kbd "u") 'undo-tree-visualize)))

     ;; enable
     (eos/funcall 'global-undo-tree-mode 1)

     #+END_SRC

**** EditorConfig

     #+BEGIN_SRC emacs-lisp

     (require 'editorconfig nil t)

     ;; enable
     (eos/funcall 'editorconfig-mode)

     #+END_SRC

*** View
**** Ibuffer

     A major mode for viewing a list of buffers.
     In Ibuffer, you can conveniently perform many operations on the
     currently open buffers, in addition to filtering your view to a
     particular subset of them, and sorting by various criteria.

     #+BEGIN_SRC emacs-lisp

     (require 'ibuffer nil t)

     #+END_SRC

**** Dashboard

     #+BEGIN_SRC emacs-lisp

     (when (require 'dashboard nil t)
       (progn
         ;; items
         (customize-set-variable 'dashboard-items
                                 '((recents . 5)
                                   (projects . 5)
                                   (agenda . 5)
                                   (bookmarks . 5)))

         ;; banners directory
         (customize-set-variable 'dashboard-banners-directory
                                 (concat user-emacs-directory "banner/"))

         ;; banner
         (customize-set-variable 'dashboard-startup-banner 1)

         ;; page separator
         (customize-set-variable 'dashboard-page-separator "

      ")

         ;; footer icon
         (customize-set-variable 'dashboard-footer-icon
                                 #(" " 0 1 (face dashboard-footer)))

         ;; footer
         (customize-set-variable 'dashboard-footer
                                 "Litany Against Fear

       I must not fear.
       Fear is the mind-killer.
       Fear is the little-death that brings total obliteration.
       I will face my fear.
       I will permit it to pass over me and through me.
       And when it has gone past I will turn the inner eye to see its path.
       Where the fear has gone there will be nothing.
       Only I will remain.
       ")

         ;; set initial buffer choice (emacsclient fix)
         (customize-set-variable 'initial-buffer-choice
                                 (lambda ()
                                   (let ((initial-buffer (get-buffer "*dashboard*")))
                                     (unless initial-buffer
                                       (setq initial-buffer (get-buffer "*scratch*")))
                                     initial-buffer)))

         ;; init dashboard after emacs initialize
         (add-hook 'after-init-hook 'dashboard-setup-startup-hook)))

     #+END_SRC

*** Graphics
**** Artist

     Artist is an Emacs lisp package that allows you to draw lines,
     rectangles and ellipses by using your mouse and/or keyboard.  The
     shapes are made up with the ascii characters |, -, / and \.

     #+BEGIN_SRC emacs-lisp

     (when (require 'artist nil t)
       (progn
         ;; custom
         ;; whether or not to incrementally update display when flood-filling
         (customize-set-variable 'artist-flood-fill-show-incrementally nil)

         ;; whether or not to remove white-space at end of lines
         (customize-set-variable 'artist-trim-line-endings nil)))

     #+END_SRC

*** Search
**** Locate

     Locate.el provides an interface to a program which searches a
     database of file names. By default, this program is the GNU locate
     command, but it could also be the BSD-style find command, or even a
     user specified command.

     #+BEGIN_SRC emacs-lisp

     (require 'locate nil t)

     #+END_SRC

**** Helm-locate

     Locate related Applications and libraries for Helm.

     #+BEGIN_SRC emacs-lisp

     (when (require 'helm-locate nil t)
       (progn
         ;; custom
         ;; disable fuzzy matching in `helm-locate'.
         (customize-set-variable 'helm-locate-fuzzy-match nil)

         ;; a list of arguments for locate program
         ;; berkeley-unix: "locate %s %s" (not working with fuzzing match?)
         (customize-set-variable 'helm-locate-command "locate %s %s")))

     #+END_SRC

**** Helm-swoop

     #+BEGIN_SRC emacs-lisp

     (when (require 'helm-swoop nil t)
       (progn
         ;; custom
         ;; if nil, you can slightly boost invoke speed in exchange for text color
         (customize-set-variable 'helm-swoop-speed-or-color nil)

         ;; split window when having multiple windows open
         (customize-set-variable 'helm-swoop-split-with-multiple-windows t)

         ;; if t, use fuzzy matching functions as well as exact matches
         (customize-set-variable 'helm-swoop-use-fuzzy-match t)

         ;; return to the opposite side of line.
         (customize-set-variable 'helm-swoop-move-to-line-cycle t)

         ;; use face to line numbers on helm-swoop buffer
         (customize-set-variable 'helm-swoop-use-line-number-face nil)

         ;; bind global
         (global-set-key (kbd "C-s") 'helm-swoop)))

     ;; binds
     (when (boundp 'helm-swoop-map)
       (progn
         (define-key helm-swoop-map (kbd "C-s")
           'helm-multi-swoop-all-from-helm-swoop)

         (define-key helm-swoop-map (kbd "C-c s c")
           'helm-multi-swoop-current-mode-from-helm-swoop)))

     #+END_SRC

**** Helm-imenu

     #+BEGIN_SRC emacs-lisp

     ;; load helm-imenu
     (when (require 'helm-imenu nil t)
       (progn
         ;; binds (C-x) prefix map
         (define-key ctl-x-map (kbd "TAB") 'helm-imenu-in-all-buffers)))

     ;; binds (local map)
     (when (boundp 'helm-imenu-map)
       (progn
         (define-key helm-imenu-map (kbd "C-M-i") 'helm-next-source)))

     #+END_SRC

*** Files
**** Dired

     This is a major mode for directory browsing and editing.

     #+BEGIN_SRC emacs-lisp

     (when (require 'dired nil t)
       (progn
         ;; enable dired-find-alternate-file
         (put 'dired-find-alternate-file 'disabled nil)))

     #+END_SRC

**** Dired-async

     This package provides a redefinition of `dired-create-file' function,
     performs copies, moves and all what is handled by `dired-create-file'
     in the background using a slave Emacs process, by means of the async.el module.

     #+BEGIN_SRC emacs-lisp

     (when (require 'dired-async nil t)
       (progn
         ;; enable dired-aysnc-mode
         (eos/funcall 'dired-async-mode 1)))

     ;; binds
     (if (boundp 'dired-mode-map)
         (progn
           (define-key dired-mode-map (kbd "RET") 'dired-find-alternate-file)
           (define-key dired-mode-map (kbd "C-j") 'dired-find-alternate-file)))

     #+END_SRC

*** Email
**** Sendmail
**** Feedmail
**** Messages
**** Gnus
*** Feed
**** Elfeed

     #+BEGIN_SRC emacs-lisp

     (require 'elfeed nil t)

     #+END_SRC

*** Bar
**** Moody

     Emacs has to be compiled with xpm support, for this package
     to work properly.

     #+BEGIN_SRC emacs-lisp

     (when (require 'moody nil t)
       (progn
         ;; remove underline
         (customize-set-variable 'x-underline-at-descent-line t)

         ;; change line height
         (customize-set-variable 'moody-mode-line-height 32)

         ;; mode-line format
         (customize-set-variable 'mode-line-format
                                 '("%e  "
                                   ;; "%*%& %l:%c | %I "
                                   ;; mode-line-mule-info
                                   "%*%& "
                                   ;; mode-line-misc-info
                                   ;; mode-line-percent-position
                                   "(%l:%c) / %I  "
                                   mode-line-misc-info
                                   " "
                                   moody-mode-line-buffer-identification
                                   " %m "
                                   (vc-mode moody-vc-mode)
                                   " "
                                   ))))

     #+END_SRC

*** Chat
**** Erc

     ERC is a powerful, modular, and extensible
     IRC client for Emacs.

     #+BEGIN_SRC emacs-lisp

     (when (require 'erc nil t)
       (progn
         ;; the string to append to the nick if it is already in use.
         (customize-set-variable 'erc-nick-uniquifier "_")

         ;; non-nil means rename buffers with network name, if available.
         (customize-set-variable 'erc-rename-buffers t)

         ;; prompt for channel key when using erc-join-channel interactively.
         (customize-set-variable 'erc-prompt-for-channel-key t)

         ;; asks before using the default password,
         ;; or whether to enter a new one.
         (customize-set-variable 'erc-prompt-for-password t)

         ;; if nil, ERC will call system-name to get this information.
         (customize-set-variable 'erc-system-name "eos")

         ;;   if non-nil, then all incoming CTCP requests will be shown.
         (customize-set-variable 'erc-paranoid t)

         ;; disable replies to CTCP requests that require a reply.
         (customize-set-variable 'erc-disable-ctcp-replies t)

         ;; be paranoid, don’t give away your machine name.
         (customize-set-variable 'erc-anonymous-login t)

         ;; show the channel key in the header line.
         (customize-set-variable 'erc-show-channel-key-p t)

         ;; kill all query (also channel) buffers of this server on QUIT.
         (customize-set-variable 'erc-kill-queries-on-quit t)

         ;; functions
         (defun eos/irc-tls ()
           "A `erc-tls function interface."
           (interactive)
           (let ((server "irc.freenode.net")
                 (nick "esac-io"))
             (erc-tls :server server :port 6697 :nick nick
                      :password (eos/lookup-password server nick 6697))))))

     ;; binds
     (when (boundp 'erc-mode-map)
       (progn
         ;; use eos/complete
         (define-key erc-mode-map (kbd "TAB") 'eos/complete)))

     #+END_SRC

**** Jabber
**** Slack
*** Shell
**** Shell

     This package defines a shell-in-a-buffer (shell mode) built on
     top of comint mode.  This is actually cmushell with things renamed
     to replace its counterpart in Emacs 18.  cmushell is more
     featureful, robust, and uniform than the Emacs 18 version.

     Since this mode is built on top of the general command-interpreter-in-
     a-buffer mode (comint mode), it shares a common base functionality,
     and a common set of bindings, with all modes derived from comint mode.
     This makes these modes easier to use.


     #+BEGIN_SRC emacs-lisp

     (when (require 'shell nil t)
       (progn
         ;; hook
         (add-hook 'shell-mode-hook
                   (lambda()
                     ;; do not display continuation lines.
                     (toggle-truncate-lines)

                     ;; disable line numbers
                     (display-line-numbers-mode 0)))))

     #+END_SRC

**** Eshell

     Despite the sheer fact that running an Emacs shell can be fun, here
     are a few of the unique features offered by Eshell:

     - Integration with the Emacs Lisp programming environment
     - A high degree of configurability.
     - The ability to have the same shell on every system Emacs has been
       ported to. Since Eshell imposes no external requirements, and
       relies upon only the Lisp functions exposed by Emacs, it is quite
       operating system independent. Several of the common UNIX
       commands, such as ls, mv, rm, ln, etc., have been implemented in
       Lisp in order to provide a more consistent work environment.


     #+BEGIN_SRC emacs-lisp

     (require 'eshell nil t)

     ;; binds
     (define-key ctl-x-map (kbd "&") 'eshell)

     #+END_SRC

*** Terminal
**** Term

     Command-interpreter-in-a-buffer package (term mode).
     The idea is that you can build specific process-in-a-buffer
     modes on top of term mode -- e.g., lisp, shell, scheme, T, soar, ...

     It seems that ~sh~ shell works better with term.

     #+BEGIN_SRC emacs-lisp

     (when (require 'term nil t)
       (progn
         ;; custom
         ;; if non-nil, is file name to use for explicitly requested inferior shell. (reference)
         (customize-set-variable 'explicit-shell-file-name
                                 (if (eq system-type "gnu/linux")
                                     "/usr/bin/fish"
                                   "/usr/local/bin/fish"))

         ;; if non-nil, add a ‘/’ to completed directories
         (customize-set-variable 'term-completion-addsuffix t)

         ;; regexp to recognize prompts in the inferior process
         ;; (customize-set-variable 'term-prompt-regexp "^\\(>\\|\\(->\\)+\\) *")
         ;; (customize-set-variable 'term-prompt-regexp ".*:.*>.*? ")

         ;; if non-nil, automatically list possibilities on partial completion.
         (customize-set-variable 'term-completion-autolist t)

         ;; if true, buffer name equals process name
         (customize-set-variable 'term-ansi-buffer-base-name t)

         ;; functions
         (defun eos/term-send-kill-line ()
           "Kill line in multi-term mode with the possibility to paste it like in a normal shell."
           (interactive)
           (when (fboundp 'term-send-raw-string)
             (progn
               (kill-line)
               (term-send-raw-string "\C-k"))))

         ;; binds (with hook)
         (add-hook 'term-mode-hook
                   (lambda ()
                     (when (and (boundp 'term-raw-map)
                                (boundp 'term-mode-map))
                       (progn
                         ;; term-raw-map
                         (define-key term-raw-map (kbd "s-q") 'term-line-mode)

                         ;; term-mode-map
                         (define-key term-mode-map (kbd "s-q") 'term-char-mode)))))

         ;; hook
         (add-hook 'term-mode-hook
                   (lambda()
                     ;; do not display continuation lines.
                     (setq truncate-lines nil)

                     ;; disable line numbers mode
                     (display-line-numbers-mode 0)))))

     #+END_SRC

**** Multi-term

     This package is for creating and managing multiple
     terminal buffers in Emacs.

     #+BEGIN_SRC emacs-lisp

     (when (require 'multi-term nil t)
       (progn
         ;; custom
         (customize-set-variable 'multi-term-program "/usr/local/bin/fish")

         ;; focus terminal window after you open dedicated window
         (customize-set-variable 'multi-term-dedicated-select-after-open-p t)

         ;; the buffer name of term buffer.
         (customize-set-variable 'multi-term-buffer-name "[TERM]")

         ;; binds (C-x) prefix
         (define-key ctl-x-map (kbd "<C-return>") 'multi-term)
         (define-key ctl-x-map (kbd "<return>") 'multi-term-dedicated-toggle)))

     #+END_SRC

**** VTerm

     VTerm is a module that implements a bridge to libvterm. It solves
     a problem with terminals and emacs, which can be pretty slow
     depending on the context due to the lack of mult-threading.
     But... it's in alpha and has a lot of issues (including
     crashing), use with care!

     On FreeBSD, there is an issue with utf8 which is better explained
     [[https://github.com/akermu/emacs-libvterm/issues/242][on github]]. Tl;dr: you need to remove the utf8 flag from the
     :command of ~vterm--process~ vterm.el to make it work.

     Also, the ~vterm-copy-mode-map~ is not assigned when
     ~vterm-copy-mode~ is toggled. I had to assign the map at
     ~vterm-copy-mode~'s definition so it could work. (not sure if I
     am the one wrong here or vterm.el)

     #+BEGIN_SRC emacs-lisp

     (when (require 'vterm nil t)
       (progn
         ;; bind
         (define-key vterm-mode-map (kbd "C-c C-q") 'vterm-copy-mode)
         (define-key vterm-copy-mode-map (kbd "C-c C-q") 'vterm-copy-mode)

         (add-hook 'vterm-mode-hook
                   (lambda ()
                     (interactive)
                     ;; disable line numbers
                     (display-line-numbers-mode 0)))))

     #+END_SRC

**** Urxvt

     #+BEGIN_SRC emacs-lisp

     (defun eos/launch/urxvt ()
       "Launch urxvt"
       (interactive)
       (eos/run/proc "urxvt"))

     #+END_SRC

*** Browser
**** Shr

     Html parse options.

     #+BEGIN_SRC emacs-lisp

     (when (require 'shr nil t)
       (progn
         (customize-set-variable 'shr-width 80)
         (customize-set-variable 'shr-use-fonts nil)
         (customize-set-variable 'shr-use-colors nil)
         (customize-set-variable 'shr-inhibit-images t)
         (customize-set-variable 'shr-blocked-images t)
         (customize-set-variable 'shr-color-visible-distance-min 10)
         (customize-set-variable 'shr-color-visible-luminance-min 80)))

     #+END_SRC

**** Eww

     Elisp www browser configuration.

     #+BEGIN_SRC emacs-lisp

     (when (require 'eww nil t)
       (progn
         ;; define google search url
         (defvar eos/eww-google-search-url "https://www.google.com/search?q="
           "URL for Google searches.")

         ;; custom search prefix
         (customize-set-variable 'eww-search-prefix eos/eww-google-search-url)
         ;; (customize-set-variable eww-search-prefix "https://duckduckgo.com/html/?q=")

         ;; custom download directory
         (customize-set-variable 'eww-download-directory "~/down")

         ;; custom checkbox symbols
         (customize-set-variable 'eww-form-checkbox-symbol "[ ]")
         (customize-set-variable 'eww-form-checkbox-selected-symbol "[X]")
         ;; (customize-set-variable eww-form-checkbox-symbol "☐") ; Unicode hex 2610
         ;; (customize-set-variable eww-form-checkbox-selected-symbol "☑") ; Unicode hex 2611

         ;; Re-write of the `eww-search-words' definition.
         (defun eos/eww-search-words ()
           "Search the web for the text between BEG and END.
           If region is active (and not whitespace), search the web for
           the text in that region.
           Else if the region is not active, and the point is on a symbol,
           search the web for that symbol.
           Else prompt the user for a search string.
           See the `eww-search-prefix' variable for the search engine used."
           (interactive)
           (let ((search-string (eos/get-selected-text-or-symbol-at-point)))
             (when (and (stringp search-string)
                        (string-match-p "\\`[[:blank:]]*\\'" search-string))
               (customize-set-variable search-string nil))
             (if (stringp search-string)
                 (eww search-string)
               (call-interactively #'eww))))
         ))

     ;; binds
     (when (boundp 'eww-mode-map)
       (progn
         (define-key eww-mode-map (kbd "C-j") 'eww-follow-link)))

     #+END_SRC

**** Browse-url

     #+BEGIN_SRC emacs-lisp

     (when (require 'browse-url nil t)
       (progn
         ;; custom

         ;; the name of the browser program used by ‘browse-url-generic’.
         (customize-set-variable 'browse-url-generic-program "eww")

         ;; function to display the current buffer in a WWW browser: eww
         (customize-set-variable 'browse-url-browser-function 'eww-browse-url)))

     #+END_SRC

*** Filter
**** Helm-ag

     #+BEGIN_SRC emacs-lisp

     (require 'helm-ag nil t)

     #+END_SRC

*** Checker
**** Spell
***** Ispell

      Aspell is a utility program that connects to the Aspell library so that
      it can function as an ispell -a replacement, as an independent spell
      checker, as a test utility to test out Aspell library features, and as
      a utility for managing dictionaries used by the library.

      Note : Ispell minor mode configuration requires aspell program.
      TIP  : On FreeBSD: pkg info aspell

      #+BEGIN_SRC emacs-lisp

      (when (require 'ispell nil t)
        (progn
          ;; custom
          ;; program invoked by M-x ispell-word and M-x ispell-region commands.
          (customize-set-variable 'ispell-program-name "aspell")))

      ;; add display-buffer-alist
      ;; (add-to-list 'display-buffer-alist
      ;;              '("\\*Choices\\*" display-buffer-below-selected))

      #+END_SRC

***** Flyspell

      Flyspell is a minor Emacs mode performing on-the-fly spelling
      checking.

      #+BEGIN_SRC emacs-lisp

      (when (require 'flyspell nil t)
        (progn
          ;; custom
          ;; string that is the name of the default dictionary
          (customize-set-variable 'flyspell-default-dictionary "english")

          ;; hooks
          (add-hook 'text-mode-hook 'flyspell-mode)
          (add-hook 'prog-mode-hook 'flyspell-prog-mode)))

      #+END_SRC

**** Syntax
***** Flycheck

      Flycheck is a modern on-the-fly syntax checking extension.

      #+BEGIN_SRC emacs-lisp

      (when (require 'flycheck nil t)
        (progn
          ;; binds
          (define-key eos-sc-map (kbd "C-g") 'keyboard-quit)
          (define-key eos-sc-map (kbd "m") 'flycheck-mode)
          (define-key eos-sc-map (kbd "M") 'flycheck-manual)
          (define-key eos-sc-map (kbd "o") 'flycheck-list-errors)
          (define-key eos-sc-map (kbd "b") 'flycheck-buffer)

          (define-key eos-sc-map
            (kbd "v") 'flycheck-verify-setup)

          (define-key eos-sc-map
            (kbd "c") 'flycheck-select-checker)

          (define-key eos-sc-map
            (kbd "d") 'flycheck-disable-checker)

          (define-key eos-sc-map
            (kbd "?") 'flycheck-describe-checker)

          ;; init flycheck mode after some programming mode
          ;; is activated (c-mode, elisp-mode, etc).
          (add-hook 'prog-mode-hook 'flycheck-mode)))

      #+END_SRC

***** Helm-flycheck

      #+BEGIN_SRC emacs-lisp

      (when (require 'helm-flycheck nil t)
        (progn
          ;; binds
          (define-key eos-sc-map (kbd "e") 'helm-flycheck)
          (define-key ctl-x-map (kbd ";") 'helm-flycheck)))

      #+END_SRC

***** Utils

      #+BEGIN_SRC emacs-lisp

      ;; auxiliary function
      (defun eos/flycheck/set-checker (checker)
        "Set flycheck CHECKER variable."
        (make-local-variable 'flycheck-checker)
        (customize-set-variable 'flycheck-checker checker))

      #+END_SRC

**** Binds

     Set syntax check related keybinds on eos-sc-map
     (C-x e).

     #+BEGIN_SRC emacs-lisp

     ;; bind eos-sc-map prefix to C-x e
     (define-key ctl-x-map (kbd "e") 'eos-sc-map)

     #+END_SRC

**** Utils

     #+BEGIN_SRC emacs-lisp

     ;; function (reference)
     ;; (defun eos/ispell/switch-dictionary ()
     ;;   "Switch dictionaries."
     ;;   (interactive)
     ;;   (let* ((dic ispell-current-dictionary)
     ;;          (change (if (string= dic "english") "brasileiro" "english")))
     ;;     (ispell-change-dictionary change)
     ;;     (message "Dictionary switched from %s to %s" dic change)))))

     #+END_SRC

*** Tester
**** Verb

     #+BEGIN_SRC emacs-lisp

     (require 'verb nil t)

     #+END_SRC

*** Comparator
**** Diff

     This package helps you explore differences between files, using the
     UNIX command diff(1). The commands are `diff' and `diff-backup'.
     You can specify options with `diff-switches'.

     #+BEGIN_SRC emacs-lisp

     (when (require 'diff nil t)
       (progn
         ;; custom
         ;; a string or list of strings specifying switches to be passed to diff
         (customize-set-variable 'diff-switches "-u")))

     #+END_SRC

**** Ediff

     This package provides a convenient way of simultaneous browsing through
     the differences between a pair (or a triple) of files or buffers.
     The files being compared, file-A, file-B, and file-C (if applicable) are
     shown in separate windows (side by side, one above the another, or in
     separate frames), and the differences are highlighted as you step
     through them.

     #+BEGIN_SRC emacs-lisp

     (when (require 'ediff nil t)
       (progn
         ;; custom
         ;; options to pass to `ediff-custom-diff-program'.
         (customize-set-variable 'ediff-custom-diff-options "-U3")

         ;; the function used to split the main window between buffer-A and buffer-B
         (customize-set-variable 'ediff-split-window-function 'split-window-horizontally)

         ;; function called to set up windows
         (customize-set-variable 'ediff-window-setup-function 'ediff-setup-windows-plain)

         ;; hooks
         (add-hook 'ediff-startup-hook 'ediff-toggle-wide-display)
         (add-hook 'ediff-cleanup-hook 'ediff-toggle-wide-display)
         (add-hook 'ediff-suspend-hook 'ediff-toggle-wide-display)))

     #+END_SRC

*** Launcher
**** Dmenu

     #+BEGIN_SRC emacs-lisp

     (when (require 'dmenu nil t)
       (progn
         ;; set dmenu-itens cache location
         (customize-set-variable
          'dmenu-save-file
          (concat user-emacs-directory "cache/dmenu-items"))

         ;; bind
         (define-key ctl-x-map (kbd "x") 'dmenu)))

     #+END_SRC

**** Helm-external

     #+BEGIN_SRC emacs-lisp

     ;; (when (require 'helm-external nil t)
     ;;   (progn
     ;;     ;; bind (C-x) prefix map
     ;;     (define-key ctl-x-map (kbd "x") 'helm-run-external-command)))

     #+END_SRC

*** Interpreter

    Generic interpreter interface configurations and customization,
    languages specific interpreters (for example: python)
    will be placed in the ~Development~ sections.

**** Comint

     This package defines a general command-interpreter-in-a-buffer
     (comint mode). The idea is that you can build specific process-in-a-buffer
     modes on top of comint mode -- e.g., Lisp, shell, scheme, T, soar, ....

     #+BEGIN_SRC emacs-lisp

     (when (require 'comint nil t)
       (progn
         ;; custom
         ;; if non-nil, assume that the subprocess echoes any input.
         (customize-set-variable 'comint-process-echoes t)

         ;; if non-nil, use comint-prompt-regexp to recognize prompts.
         (customize-set-variable 'comint-use-prompt-regexp t)

         ;; regexp to recognize prompts in the inferior process.
         ;; (customize-set-variable 'comint-prompt-regexp ".*:.*>.*? ")

         ;; value to use for TERM when the system uses terminfo.
         (customize-set-variable 'comint-terminfo-terminal "eterm-color")))

     #+END_SRC

**** IELM

     #+BEGIN_SRC emacs-lisp

     (when (require 'ielm nil t)
       (progn
         ;; custom
         ;; if non-nil, after entering the first line of
         ;; an incomplete sexp, a newline will be inserted after the prompt.
         (customize-set-variable 'ielm-dynamic-multiline-inputs t)

         ;; if non-nil, IELM will beep on error
         (customize-set-variable 'ielm-noisy nil)

         ;; prompt used in IELM
         (customize-set-variable 'ielm-prompt "elisp > ")

         ;; if non-nil, the IELM prompt is read only
         (customize-set-variable 'ielm-prompt-read-only nil)))

     #+END_SRC

**** Sql

     Specialized ~comint.el~ for SQL interpreters.

     #+BEGIN_SRC emacs-lisp

     (require 'sql nil t)

     #+END_SRC

*** Compositor
**** Compton

     Compton is a compositor based on Dana Jansens' version of xcompmgr
     (which itself was written by Keith Packard). It includes some
     improvements over the original xcompmgr, like window frame opacity and
     inactive window transparency.

     Start compton after emacs initialize.

     #+BEGIN_SRC emacs-lisp

     ;; start compton after emacs initialize
     (add-hook 'after-init-hook
               (lambda ()
                 (eos/run/proc "compton")))

     #+END_SRC

**** Transset

     Transset is a simple program for X servers supporting the XFIXES,
     DAMAGE, and COMPOSITE extensions.  It lets the user set the
     transparency on a window.

     #+BEGIN_SRC emacs-lisp

     (defun eos/transset-set (opacity)
       "Set transparency on frame window specify by OPACITY."
       (interactive "nOpacity: ")
       (let ((opacity (or opacity 1.0)))
         (when (executable-find "transset")
           (progn
             (async-shell-command (format "transset -a %.1f" opacity)))
           (message "transset not found"))))

     ;; hooks
     (add-hook 'after-make-frame-functions
               (lambda (frame)
                 (interactive)
                 (eos/transset-set 0.9)))

     ;; init after exwm
     (add-hook 'exwm-init-hook
               (lambda ()
                 (interactive)
                 (eos/transset-set 0.9)))

     #+END_SRC

*** Calculator
**** Calc
**** Helm-calc

     #+BEGIN_SRC emacs-lisp

     (if (fboundp 'helm-calcul-expression)
         (define-key ctl-x-map (kbd "C-/") 'helm-calcul-expression))

     #+END_SRC

*** Remote Access
**** Tramp

     TRAMP is for transparently accessing remote files from within Emacs.
     TRAMP enables an easy, convenient, and consistent interface to remote
     files as if they are local files.  TRAMP’s transparency extends to
     editing, version control, and dired.

     #+BEGIN_SRC emacs-lisp

     (when (require 'tramp nil t)
       (progn
         ;; custom
         ;; set tramp default method
         (customize-set-variable 'tramp-default-method "ssh")

         ;; if non-nil, chunksize for sending input to local process.
         ;; (customize-set-variable 'tramp-chunksize 512)

         ;; a value of t would require an immediate reread during filename completion,
         ;; nil means to use always cached values for the directory contents.
         (customize-set-variable 'tramp-completion-reread-directory-timeout nil)

         ;; set tramp verbose level
         (customize-set-variable 'tramp-verbose 4)

         ;; file which keeps connection history for tramp connections.
         (customize-set-variable
          'tramp-persistency-file-name
          (concat (expand-file-name user-emacs-directory) "cache/tramp"))

         ;; connection timeout in seconds
         (customize-set-variable 'tramp-connection-timeout 60)))

     #+END_SRC

**** Helm-tramp

     #+BEGIN_SRC emacs-lisp

     (require 'helm-tramp nil t)

     #+END_SRC

*** Download
**** Torrent
***** Mentor
***** Aria2c
*** Screen
**** Locker
***** Slock

      #+BEGIN_SRC emacs-lisp

      (define-key ctl-x-map (kbd "<end>")
        (lambda ()
          (interactive)
          (eos/run/proc "my.lock")))

      #+END_SRC

**** Shot
***** Scrot

      #+BEGIN_SRC emacs-lisp

      (global-set-key (kbd "<print>")
                      (lambda ()
                        (interactive)
                        (eos/run/proc "scrot")))

      #+END_SRC

*** Controls
**** Volume

     #+BEGIN_SRC emacs-lisp

     ;; control functions: volume
     ;; (defun eos/toggle-audio ()
     ;;   "Toggle audio (mute or unmute)."
     ;;   (interactive)
     ;;   (async-shell-command "amixer -D default set Master"))

     (defun eos/raise-volume ()
       "Raise the volume (factor +5)."
       (interactive)
       (async-shell-command "amixer -D default set Master 5+ unmute"))

     (defun eos/lower-volume ()
       "Lower the volume (factor -5)."
       (interactive)
       (async-shell-command "amixer -D default set Master 5- unmute"))

     ;; bind
     ;; (define-key ctl-x-map (kbd "C-0") 'eos/toggle-audio)
     (global-set-key (kbd "s--") 'eos/lower-volume)
     (global-set-key (kbd "s-=") 'eos/raise-volume)

     #+END_SRC

*** Calendar
*** Multimedia
**** Helm-youtube

     #+BEGIN_SRC emacs-lisp

     (require 'helm-youtube nil t)

     ;; binds
     (when (boundp 'helm-command-map)
       (progn
         (define-key helm-command-map (kbd "m") 'helm-youtube)))

     #+END_SRC

**** Emms

     Emms is the Emacs Multi-Media System. It tries to be a clean and small
     application to play multimedia files from Emacs using external
     players. The basic functionality of Emms consists of three parts:
     The core, the sources, and the players.

     #+BEGIN_SRC emacs-lisp

     (when (require 'emms nil t)
       (progn
         ;; the 'emms-setup' feature is provided by the file 'emms-setup.el'
         (require 'emms-setup nil t)

         ;; custom
         ;; list of players that emms can use (only mpv)
         (customize-set-variable 'emms-player-list '(emms-player-mpv))

         ;; the default directory to look for media files.
         (customize-set-variable
          'emms-source-file-default-directory (expand-file-name "~/media"))

         ;; hooks
         ;; disable emms mode line
         (add-hook 'emms-playlist-mode-hook
                   (lambda ()
                     (when (and (boundp 'emms-mode-line-active-p)
                                (fboundp 'emms-mode-line-disable))
                       (progn
                         (if emms-mode-line-active-p
                             (emms-mode-line-disable))))))))

     ;; if emms is available, enable it
     (when (and (fboundp 'emms-all)
                (fboundp 'emms-default-players))
       (progn
         (funcall 'emms-all)
         (funcall 'emms-default-players)))

     #+END_SRC

*** Office
**** Org

     #+BEGIN_SRC emacs-lisp

     ;; custom
     ;; when non-nil, fontify code in code blocks
     (customize-set-variable 'org-src-fontify-natively t)

     ;; if non-nil, the effect of TAB in a code block is as if it were
     ;; issued in the language major mode buffer
     (customize-set-variable 'org-src-tab-acts-natively t)

     ;; indentation for the content of a source code block.
     (customize-set-variable 'org-edit-src-content-indentation 0)

     ;; confirm before evaluation
     (customize-set-variable 'org-confirm-babel-evaluate nil)

     ;; how the source code edit buffer should be displayed
     (customize-set-variable 'org-src-window-setup 'current-window)

     ;; non-nil means C-a and C-e behave specially in headlines and items
     (customize-set-variable 'org-special-ctrl-a/e t)

     (add-hook 'org-mode-hook
               (lambda ()
                 ;; do not truncate lines
                 (setq truncate-lines nil)

                 ;; set company backends
                 (eos/company/set-backends
                  '((company-ispell
                     company-yasnippet)
                    (company-files)))))

     ;; binds
     (define-key org-mode-map (kbd "C-M-i") 'eos/company-or-indent)

     #+END_SRC

**** Org-Agenda

     #+BEGIN_SRC emacs-lisp

     (setq org-agenda-include-diary t)

     #+END_SRC

**** Tex

     #+BEGIN_SRC emacs-lisp

     (when (require 'tex-mode nil t)
       (progn
         ;; custom
         ;; hooks
         ))

     #+END_SRC

**** Text

     #+BEGIN_SRC emacs-lisp

     (when (require 'text-mode nil t)
       (progn
         ;; binds
         (define-key text-mode-map (kbd "C-c C-g") 'keyboard-quit)
         (define-key text-mode-map (kbd "TAB") 'eos/complete-or-indent)
         (define-key text-mode-map (kbd "C-M-i") 'eos/company-or-indent)

         (define-key text-mode-map (kbd "C-c C-k") 'with-editor-cancel)
         (define-key text-mode-map (kbd "C-c C-c") 'with-editor-finish)

         ;; text mode hook
         (add-hook 'text-mode-hook
                   (lambda ()
                     ;; turn on auto fill mode
                     (turn-on-auto-fill)

                     ;; set company backends
                     (eos/company/set-backends
                      '((company-ispell
                         company-keywords
                         company-capf
                         company-dabbrev)
                        (company-files)))))))

     #+END_SRC

**** Markdown

     #+BEGIN_SRC emacs-lisp

     (when (require 'markdown-mode nil t)
       (progn
         ;; custom
         (customize-set-variable 'markdown-command "multimarkdown")))

     ;; binds
     (when (boundp 'markdown-mode-map)
       (progn
         (define-key markdown-mode-map (kbd "TAB") 'eos/complete-or-indent)))

     #+END_SRC

**** DocView
**** Dictionary

*** Notification
**** Notifications

     For proper usage, Emacs must be started in an environment with an
     active D-Bus session bus.

     #+BEGIN_SRC emacs-lisp

     (require 'notifications nil t)

     #+END_SRC

*** Documentation
**** Eldoc

     As you type a function's symbol name as part of a sexp,
     it will print the argument list for that function.
     Behavior is not identical; for example, you need not actually
     type the function name, you need only move point around in a sexp that
     calls it.  Also, if point is over a documented variable, it will print
     the one-line documentation for that variable instead, to remind you of
     that variable's meaning.

     #+BEGIN_SRC emacs-lisp

     (require 'eldoc nil t)

     #+END_SRC

**** Man

     #+BEGIN_SRC emacs-lisp

     (when (require 'man nil t)
       (progn
         ;; hooks
         (add-hook 'Man-mode-hook
                   (lambda ()
                     ;; don't truncate lines
                     (setq truncate-lines nil)))))

     ;; binds
     (when (boundp 'Man-mode-map)
       (progn
         (define-key Man-mode-map (kbd "C-j") 'push-button)))

     #+END_SRC

**** Helm-woman

     #+BEGIN_SRC emacs-lisp

     (when (require 'helm-man nil t)
       (progn
         ;; bind
         (define-key eos-docs-map (kbd "m") 'helm-man-woman)))

     #+END_SRC

**** Dash

     #+BEGIN_SRC emacs-lisp

     (when (require 'dash-docs nil t)
       (progn
         ;; custom (fix async?)
         ;; (customize-set-variable
         ;;  'dash-docs-use-workaround-for-emacs-bug t)

         ;; bind
         (define-key eos-docs-map (kbd "u") 'dash-docs-update-docset)))

     #+END_SRC

**** Helm-dash

     #+BEGIN_SRC emacs-lisp

     (when (require 'helm-dash nil t)
       (progn
         ;; disable helm dash debug
         (customize-set-variable 'helm-dash-enable-debugging nil)

         ;; set browser function
         (customize-set-variable 'helm-dash-browser-func 'eww)

         ;; binds
         (define-key eos-docs-map (kbd "l") 'helm-dash)
         (define-key eos-docs-map (kbd "p") 'helm-dash-at-point)
         (define-key eos-docs-map (kbd "i") 'helm-dash-install-docset)
         (define-key eos-docs-map (kbd "a") 'helm-dash-activate-docset)))

     ;; activate docset
     (defun eos/dash/activate-docset (docset)
       "Activate a DOCSET, if available."
       (when (fboundp 'helm-dash-activate-docset)
         (funcall 'helm-dash-activate-docset docset)))

     #+END_SRC

**** Rfc-mode

     Mode so browser local RFC files. To make it work, just download
     the RFC files and changhe the 'rfc-mode-directory' dir to match
     the path where all the RFCs were extracted.

     The RFC collection can be downloaded [[https://www.rfc-editor.org/retrieve/bulk][here]].

     #+BEGIN_SRC emacs-lisp

     (when (require 'rfc-mode nil t)
       (progn
         ;; custom
         ;; the directory where RFC documents are stored
         (customize-set-variable 'rfc-mode-directory "~/rfc/")

         ;; change color from section title to match theme
         (custom-set-faces
           '(rfc-mode-document-section-title-face ((t (:inherit nil :foreground "indian red")))))))

     #+END_SRC

**** Binds

     #+BEGIN_SRC emacs-lisp

     ;; bind documentation related functions on eos-docs-map
     (define-key eos-docs-map (kbd "C-g") 'keyboard-quit)

     ;; bind eos-docs-map under ctl-x-map
     (define-key ctl-x-map (kbd "l") 'eos-docs-map)

     #+END_SRC

*** Completion
**** Completion

     After you type a few characters, pressing the `complete'
     key inserts the rest of the word you are likely to type.

     #+BEGIN_SRC emacs-lisp

     (when (require 'completion nil t)
       (progn
         ;; custom
         ;; how far to search in the buffer when looking for completions. Hide
         ;; in number of characters.  If nil, search the whole buffer.
         (customize-set-variable 'completion-search-distance 0)

         ;; if non-nil, the next completion prompt does a cdabbrev search.
         (customize-set-variable 'completion-cdabbrev-prompt-flag t)

         ;; non-nil means show help message in *Completions* buffer.
         (customize-set-variable 'completion-show-help t)

         ;; non-nil means separator characters mark previous word as used
         (customize-set-variable 'completion-on-separator-character t)

         ;;   the filename to save completions to.
         (customize-set-variable
          'save-completions-file-name
          (expand-file-name "cache/completitions" user-emacs-directory))

         ;; non-nil means save most-used completions when exiting emacs
         (customize-set-variable 'save-completions-flag t)

         ;;    Discard a completion if unused for this many hours. Hide
         ;; (1 day = 24, 1 week = 168).  If this is 0, non-permanent completions
         ;; will not be saved unless these are used.  Default is two weeks.
         (customize-set-variable 'save-completions-retention-time 0)

         ;; binds
         (global-set-key (kbd "M-\\") 'complete)

         ;; enable
         ;; dynamic completion on
         (eos/funcall 'dynamic-completion-mode 1)))

     ;; add display-buffer-alist
     (add-to-list 'display-buffer-alist
                  '("\\*Completions\\*" display-buffer-below-selected))

     #+END_SRC

**** Dabbrev

     The purpose with this package is to let you write just a few
     characters of words you've written earlier to be able to expand
     them.

     #+BEGIN_SRC emacs-lisp

     (when (require 'dabbrev nil t)
       (progn
         ;; custom
         ;; non-nil means case sensitive search.
         (customize-set-variable 'dabbrev-upcase-means-case-search t)

         ;; whether dabbrev treats expansions as the same if they differ in case
         ;; a value of nil means treat them as different.
         (customize-set-variable 'dabbrev-case-distinction t)))

     #+END_SRC

**** Company

     Company is a modular completion framework.
     Modules for retrieving completion candidates are called backends,
     modules for displaying them are front-ends.

     #+BEGIN_SRC emacs-lisp

     (when (require 'company nil t)
       (progn
         ;; set echo delay
         (customize-set-variable 'company-echo-delay 0.0)

         ;; disable idle delay
         (customize-set-variable 'company-idle-delay nil)

         ;; set tooltip limit
         (customize-set-variable 'company-tooltip-limit 20)

         ;; set prefix length
         (customize-set-variable 'company-minimum-length 2)

         ;; cycle selection
         (customize-set-variable 'company-selection-wrap-around t)

         ;; sort by frequency
         (customize-set-variable 'company-transformers
                                 '(company-sort-by-occurrence))

         ;; enable dabbrev downcase (most common)
         (customize-set-variable 'company-dabbrev-downcase nil)

         ;; align annotations true
         (customize-set-variable 'company-tooltip-align-annotations nil)

         ;; show candidates number
         ;; to select completions use: M-1, M-2, etc..
         (customize-set-variable 'company-show-numbers t)

         ;; binds
         (define-key eos-complete-map (kbd "y") 'company-yasnippet)
         (define-key eos-complete-map (kbd "s") 'company-ispell)
         (define-key eos-complete-map (kbd "t") 'company-gtags)
         (define-key eos-complete-map (kbd "'") 'company-dabbrev-code)
         (define-key eos-complete-map (kbd "/") 'company-files)))

     ;; enable globally
     (eos/funcall 'global-company-mode 1)

     ;; binds
     (when (boundp 'company-active-map)
       (progn
         (define-key company-active-map (kbd "<tab>") 'company-complete-selection)
         (define-key company-active-map (kbd "C-j") 'company-complete-selection)
         (define-key company-active-map (kbd "C-n") 'company-select-next)
         (define-key company-active-map (kbd "C-p") 'company-select-previous)))

     #+END_SRC

**** Company-statistics

     #+BEGIN_SRC emacs-lisp

     (when (require 'company-statistics nil t)
       (progn
         ;; custom
         ;; set company-statistics cache location
         (customize-set-variable
          'company-statistics-file
          (concat user-emacs-directory "cache/company-statistics-cache.el"))))

     #+END_SRC

**** Yasnippet

     #+BEGIN_SRC emacs-lisp

     (when (require 'yasnippet nil t)
       (progn
         ;; binds
         (define-key eos-complete-map (kbd "e") 'yas-expand)
         (define-key eos-complete-map (kbd "i") 'yas-insert-snippet)
         (define-key eos-complete-map (kbd "v") 'yas-visit-snippet-file)))

     ;; enable
     (eos/funcall 'yas-global-mode 1)

     #+END_SRC

**** Helm-company

     #+BEGIN_SRC emacs-lisp

     (when (require 'helm-company nil t)
       (progn
         ;; custom
         ;; enable fuzzy matching for helm company
         (customize-set-variable 'helm-company-fuzzy-match t)))

     (when (boundp 'helm-company-map)
       (define-key helm-company-map (kbd "SPC") 'helm-keyboard-quit)
       (define-key helm-company-map (kbd "TAB") 'helm-maybe-exit-minibuffer)
       (define-key helm-company-map (kbd "C-j") 'helm-maybe-exit-minibuffer))

     #+END_SRC

**** Utils

     #+BEGIN_SRC emacs-lisp

     ;; set company backends
     (defun eos/company/set-backends (backends)
       "Set company BACKENDS."
       (make-local-variable 'company-backends)
       (when (boundp 'company-backends)
         (setq company-backends backends)))

     ;; calls helm-company if its bounded
     (defun eos/helm-company ()
       "Helm company complete wrapper."
       (interactive)
       (when (fboundp 'helm-company)
         (helm-company)))

     ;; company or indent
     (defun eos/company-or-indent ()
       "Complete or indent (TAB)."
       (interactive)
       (if (looking-at "\\_>")
           (progn
             (when (fboundp 'helm-company)
               (helm-company)))
         (indent-according-to-mode)))

     (defun eos/complete-or-indent ()
       (interactive)
       (if (looking-at "\\_>")
           (dabbrev-expand nil)
         (indent-according-to-mode)))

     (defun eos/complete-at-point-or-indent ()
       "This smart tab is minibuffer compliant: it acts as usual in
     the minibuffer. Else, if mark is active, indents region. Else if
     point is at the end of a symbol, expands it. Else indents the
     current line."
       (interactive)
       (if (minibufferp)
           (unless (minibuffer-complete)
             (complete-symbol nil))
         (if mark-active
             (indent-region (region-beginning)
                            (region-end))
           (if (looking-at "\\_>")
               (complete-symbol nil)
             (indent-according-to-mode)))))

     #+END_SRC

**** Binds

     #+BEGIN_SRC emacs-lisp

     ;; exit, keyboard quit
     (define-key eos-complete-map (kbd "C-g") 'keyboard-quit)

     ;; binds (global)
     (global-set-key (kbd "TAB") 'eos/complete-or-indent)
     (global-set-key (kbd "C-M-i") 'eos/company-or-indent)

     ;; binds eos-complete-map prefix M-] map
     (global-set-key (kbd "C-M-c") 'eos-complete-map)

     #+END_SRC

*** Navigation
**** Helm-gtags

     #+BEGIN_SRC emacs-lisp

     (when (require 'helm-gtags nil t)
       (progn
         ;; custom
         (customize-set-variable 'helm-gtags-ignore-case t)
         (customize-set-variable 'helm-gtags-auto-update t)
         (customize-set-variable 'helm-gtags-pulse-at-cursor t)
         (customize-set-variable 'helm-gtags-use-input-at-cursor t)
         (customize-set-variable 'helm-gtags-suggested-key-mapping t)

         ;; binds
         (define-key eos-tags-map (kbd "t") 'helm-gtags-dwim)
         (define-key eos-tags-map (kbd "s") 'helm-gtags-select)
         (define-key eos-tags-map (kbd "f") 'helm-gtags-find-tag)
         (define-key eos-tags-map (kbd "+") 'helm-gtags-show-stack)
         (define-key eos-tags-map (kbd "a") 'helm-gtags-parse-file)
         (define-key eos-tags-map (kbd "c") 'helm-gtags-create-tags)
         (define-key eos-tags-map (kbd "u") 'helm-gtags-update-tags)
         (define-key eos-tags-map (kbd "p") 'helm-gtags-find-pattern)
         (define-key eos-tags-map (kbd "r") 'helm-gtags-find-rtag)
         (define-key eos-tags-map (kbd "o") 'helm-gtags-find-tag-other-window)))

     ;; enable helm-gtags
     (eos/funcall 'helm-gtags-mode 1)

     #+END_SRC

**** Binds

     Set tags (navigation) keybinds on eos-tags-map (C-x t).

     #+BEGIN_SRC emacs-lisp

     ;; exit, keyboard quit
     (define-key eos-tags-map (kbd "C-g") 'keyboard-quit)

     ;; ctl-x-map bind (C-x t)
     (define-key ctl-x-map (kbd "t") 'eos-tags-map)

     #+END_SRC

*** Debugging
**** Gud

     #+BEGIN_SRC emacs-lisp

     (require 'gud nil t)

     #+END_SRC

**** Rmsbolt

     A compiler output viewer.

     #+BEGIN_SRC emacs-lisp

     (when (require 'rmsbolt nil t)
       (progn
         ;; custom
         ;; which output assembly format to use.
         (customize-set-variable 'rmsbolt-asm-format "att")

         ;;    whether we should disassemble an output binary
         (customize-set-variable 'rmsbolt-disassemble t)

         ;; rmsbolt mode lighter
         (customize-set-variable 'rmsbolt-mode-lighter "RMS")))

     #+END_SRC

*** Building
**** Cmake-ide

     #+BEGIN_SRC emacs-lisp

     (when (require 'cmake-ide nil t)
       (progn
         ;; hooks
         (add-hook 'c-mode-hook 'cmake-ide-setup)
         (add-hook 'c++-mode-hook 'cmake-ide-setup)))

     #+END_SRC

*** Compilation
**** Compile

     #+BEGIN_SRC emacs-lisp

     (require 'compile nil t)

     ;; don't truncate lines
     (add-hook 'compilation-mode-hook
               (lambda ()
                 (setq truncate-lines nil)))

     ;; fix compilation buffer colors
     (add-hook 'compilation-filter-hook
               (lambda ()
                 (when (eq major-mode 'compilation-mode)
                   (ansi-color-apply-on-region
                    compilation-filter-start (point-max)))))

     #+END_SRC

**** Helm-compile

     #+BEGIN_SRC emacs-lisp

     (add-to-list 'load-path
                  (concat user-emacs-directory "elpa/helm-compile"))

     (require 'helm-compile nil t)

     #+END_SRC

*** Versioning

    Version control packages.

**** Magit

     Magit is an interface to the version control system Git,
     implemented as an Emacs package.  Magit aspires to be a complete
     Git porcelain.

     #+BEGIN_SRC emacs-lisp

     (when (require 'magit nil t)
       (progn
         ;; binds
         (define-key ctl-x-map (kbd "j") 'magit-status)))

     #+END_SRC

*** Project Management
**** Ede

     EDE is the top level Lisp interface to a
     project management scheme for Emacs.

     #+BEGIN_SRC emacs-lisp

     (require 'ede nil t)

     #+END_SRC

**** Projectile

     This package provides easy project management and navigation.
     The concept of a project is pretty basic - just a folder containing
     special file. Currently git, mercurial and bazaar repos are
     considered projects by default. If you want to mark a folder
     manually as a project just create an empty .projectile file in it.

     #+BEGIN_SRC emacs-lisp

     (when (require 'projectile nil t)
       (progn
         ;; custom
         ;; enable cache and choose indexing method
         (customize-set-variable 'projectile-enable-caching t)
         (customize-set-variable 'projectile-indexing-method 'hybrid)
         (customize-set-variable 'projectile-completion-system 'helm)

         ;; set bookmarks file localtion (cache)
         (customize-set-variable 'projectile-known-projects-file
                                 (concat user-emacs-directory "cache/projectile-bookmarks.eld"))

         (customize-set-variable 'projectile-cache-file
                                 (concat user-emacs-directory "cache/projectile.cache"))

         ;; binds
         (define-key eos-pm-map (kbd "g") 'projectile-grep)
         (define-key eos-pm-map (kbd "t") 'projectile-find-tag)
         (define-key eos-pm-map (kbd "x") 'projectile-compile-project)
         (define-key eos-pm-map (kbd "!") 'projectile-run-eshell)
         (define-key eos-pm-map (kbd "o") 'projectile-switch-project)
         (define-key eos-pm-map (kbd "r") 'projectile-replace-regexp)
         (define-key eos-pm-map (kbd "R") 'projectile-replace)
         (define-key eos-pm-map (kbd "s") 'projectile-save-project-buffers)
         (define-key eos-pm-map (kbd "d") 'projectile-discover-projects-in-directory)
         (define-key eos-pm-map (kbd "c") 'projectile-cleanup-known-projects)
         (define-key eos-pm-map (kbd "C") 'projectile-invalidate-cache)
         (define-key eos-pm-map (kbd "U") 'projectile-purge-dir-from-cache)
         (define-key eos-pm-map (kbd "u") 'projectile-purge-file-from-cache)
         (define-key eos-pm-map (kbd ".") 'projectile-edit-dir-locals)
         (define-key eos-pm-map (kbd "k") 'projectile-kill-buffers)
         (define-key eos-pm-map (kbd "D") 'projectile-remove-known-project)))

     ;; enable
     (eos/funcall 'projectile-mode)

     #+END_SRC

**** Helm-projectile

     Helm-projectile is used as projectile frontend/interface.

     #+BEGIN_SRC emacs-lisp

     (when (require 'helm-projectile nil t)
       (progn
         ;; binds
         (define-key eos-pm-map (kbd "p") 'helm-projectile-ag)
         (define-key eos-pm-map (kbd "n") 'helm-projectile-recentf)
         (define-key eos-pm-map (kbd "/") 'helm-projectile-find-dir)
         (define-key eos-pm-map (kbd "f") 'helm-projectile-find-file)
         (define-key eos-pm-map (kbd "b") 'helm-projectile-browse-dirty-projects)
         (define-key eos-pm-map (kbd "a")
           'helm-projectile-find-file-in-known-projects)

         ;; helm-swoop
         (define-key eos-pm-map (kbd "S") 'helm-multi-swoop-projectile)

         ;; dwin
         (define-key eos-pm-map (kbd "w") 'helm-projectile-find-file-dwim)

         ;; hooks
         (add-hook 'projectile-mode-hook 'helm-projectile-on)))

     #+END_SRC

**** Binds

     Set project manager keybinds on eos-pm-map (C-x p).

     #+BEGIN_SRC emacs-lisp

     ;; exit, keyboard quit
     (define-key eos-pm-map (kbd "C-g") 'keyboard-quit)

     ;; set ctl-x-map prefix (C-x p)
     (define-key ctl-x-map (kbd "p") 'eos-pm-map)

     #+END_SRC

** Development
*** C/C++
**** Common

     #+BEGIN_SRC emacs-lisp

     ;; c/c++ garage
     (defun eos/cc/set-company-backends ()
       "Set C/C++ common company backends."
       (eos/company/set-backends
        '((company-c-headers)
          (company-irony
           company-yasnippet)
          (company-files))))

     #+END_SRC

**** CC-mode

     This package provides GNU Emacs major modes for editing C, C++,
     Objective-C, Java, CORBA's IDL, Pike and AWK code.  As of the
     latest Emacs and XEmacs releases, it is the default package for
     editing these languages.  This package is called "CC Mode", and
     should be spelled exactly this way.

     #+BEGIN_SRC emacs-lisp

     (when (require 'cc-mode nil t)
       (progn
         ;; hooks
         (add-hook 'c-mode-hook
                   (lambda ()
                     ;; set cc common company backends
                     (eos/cc/set-company-backends)

                     ;; set dash docset
                     (eos/dash/activate-docset '"C")

                     ;; set flycheck checker
                     (eos/flycheck/set-checker 'c/c++-clang)

                     ;; load rtags
                     (eos/cc/load-rtags)))

         (add-hook 'c++-mode-hook
                   (lambda ()
                     ;; set cc common backends (company and flycheck)
                     (eos/cc/set-company-backends)

                     ;; set flycheck checker
                     (eos/flycheck/set-checker 'c++-cppcheck)

                     ;; set dash docset
                     (eos/dash/activate-docset '"C++")

                     ;; load rtags
                     (eos/cc/load-rtags)))))

     ;; binds
     (when (boundp 'c-mode-map)
       (progn
         ;; set rtags prefix map in c-mode map (C-c r)
         (define-key c-mode-map (kbd "C-c r") 'eos-rtags-map)

         ;; complete or indent
         (define-key c-mode-map (kbd "TAB") 'eos/complete-or-indent)
         (define-key c-mode-map (kbd "C-M-i") 'eos/company-or-indent)))

     #+END_SRC

**** Rtags

     RTags is a client/server application that indexes C/C++ code and keeps a
     persistent file-based database of references, declarations, definitions,
     symbolnames etc. There’s also limited support for ObjC/ObjC++.

     #+BEGIN_SRC emacs-lisp

     (defun eos/cc/load-rtags ()
       "Load rtags manually."
       (eos/load-file (concat user-emacs-directory "rtags/src/rtags.el"))

       ;; load helm-rtags
       (eos/load-file (concat user-emacs-directory "rtags/src/helm-rtags.el"))

       ;; set rtags binary path
       (customize-set-variable
        'rtags-path
        (concat user-emacs-directory "rtags/build/bin/"))

       ;; set helm as the frontend
       (customize-set-variable 'rtags-display-result-backend 'helm)
       (customize-set-variable 'rtags-completing-read-behavior 'helm))

     #+END_SRC

**** Irony

     #+BEGIN_SRC emacs-lisp

     (when (require 'irony nil t)
       (progn
         ;; irony hooks
         (add-hook 'irony-mode-hook 'electric-pair-mode)

         ;; mode hooks (init)
         (add-hook 'c-mode-hook 'irony-mode)
         (add-hook 'c++-mode-hook 'irony-mode)
         (add-hook 'objc-mode-hook 'irony-mode)))

     #+END_SRC

**** Irony-cdb

     #+BEGIN_SRC emacs-lisp

     (when (require 'irony-cdb nil t)
       (progn
         ;; hooks
         (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)))

     #+END_SRC

**** Company-irony

     This package provides a company-mode asynchronous
     completion backend for the C, C++ and Objective-C languages.


     #+BEGIN_SRC emacs-lisp

     (when (require 'company-irony nil t)
       (progn
         ;; hooks
         (add-hook 'irony-mode-hook 'company-irony-setup-begin-commands)))

     #+END_SRC

**** Company-c-headers

     #+BEGIN_SRC emacs-lisp

     (require 'company-c-headers nil t)

     #+END_SRC

**** Binds

     #+BEGIN_SRC emacs-lisp

     ;; eos rtags prefix map (todo revise)
     (define-key eos-rtags-map (kbd "C-g") 'keyboard-quit)
     (define-key eos-rtags-map (kbd "l") 'rtags-taglist)
     (define-key eos-rtags-map (kbd "I") 'rtags-install)
     (define-key eos-rtags-map (kbd "y") 'rtags-symbol-type)
     (define-key eos-rtags-map (kbd "l") 'rtags-symbol-info)
     (define-key eos-rtags-map (kbd "n") 'rtags-rename-symbol)
     (define-key eos-rtags-map (kbd "m") 'rtags-asm-file)
     (define-key eos-rtags-map (kbd "h") 'rtags-find-file-history)
     (define-key eos-rtags-map (kbd "x") 'rtags-fixit)
     (define-key eos-rtags-map (kbd "d") 'rtags-diagnostics)
     (define-key eos-rtags-map (kbd "c") 'rtags-compile-file)
     (define-key eos-rtags-map (kbd "-") 'rtags-compilation-flags)
     (define-key eos-rtags-map (kbd ".") 'rtags-find-functions-called-by-this-function)
     (define-key eos-rtags-map (kbd "t") 'rtags-find-symbol-at-point)
     (define-key eos-rtags-map (kbd "r") 'rtags-find-references-at-point)
     ;; (define-key eos-rtags-map (kbd "p") 'rtags-find-all-references-at-point)
     ;; (define-key eos-rtags-map (kbd "i") 'rtags-imenu)
     ;; (define-key eos-rtags-map (kbd "s") 'rtags-find-symbol)


     #+END_SRC

*** Lisp
**** Lisp-mode

     #+BEGIN_SRC emacs-lisp

     (when (require 'lisp-mode nil t)
       (progn
         ;; custom
         ;; number of columns to indent the second line of a (def...) form
         (customize-set-variable 'lisp-body-indent 2)))

     #+END_SRC

*** Elisp
**** Elisp-mode

     #+BEGIN_SRC emacs-lisp

     (when (require 'elisp-mode nil t)
       (progn
         ;; hooks
         ;; enable minor modes
         (add-hook 'emacs-lisp-mode-hook
                   (lambda()
                     (eos/funcall 'eldoc-mode 1)))

         (add-hook 'lisp-interaction-mode-hook
                   (lambda()
                     (eos/funcall 'eldoc-mode 1)))

         ;; set backends
         (add-hook 'emacs-lisp-mode-hook
                   (lambda ()
                     ;; set company backends
                     (eos/company/set-backends
                      '((company-elisp
                         company-yasnippet)
                        (company-files)))

                     ;; set flycheck checker
                     (eos/flycheck/set-checker 'emacs-lisp)

                     ;; activate dash docset (emacs)
                     (eos/dash/activate-docset "Emacs Lisp")))))

     ;; binds
     (when (boundp 'emacs-lisp-mode-map)
       (progn
         (define-key emacs-lisp-mode-map (kbd "C-c C-f") 'eval-defun)
         (define-key emacs-lisp-mode-map (kbd "C-c C-r") 'eval-region)
         (define-key emacs-lisp-mode-map (kbd "C-c C-c") 'eval-buffer)
         ;; (define-key emacs-lisp-mode-map (kbd "C-c TAB") 'helm-lisp-completion-at-point)

         (define-key emacs-lisp-mode-map (kbd "TAB") 'eos/complete-or-indent)
         (define-key emacs-lisp-mode-map (kbd "C-M-i") 'eos/company-or-indent)

         ;; ubind, qualaty of life
         (define-key emacs-lisp-mode-map (kbd "DEL") 'nil)
         (define-key emacs-lisp-mode-map (kbd "ESC") 'nil)
         (define-key emacs-lisp-mode-map (kbd "C-x") 'nil)
         (define-key emacs-lisp-mode-map (kbd "C-M-x") 'nil)
         (define-key emacs-lisp-mode-map (kbd "C-M-q") 'nil)))

     #+END_SRC

**** Company-elisp

     #+BEGIN_SRC emacs-lisp

     (require 'company-elisp nil t)

     #+END_SRC

*** Sh
**** Sh-script

     #+BEGIN_SRC emacs-lisp

     (when (require 'sh-script nil t)
       (progn
         ;; hooks
         (add-hook 'sh-mode-hook
                   (lambda ()
                     ;; set company backends
                     (eos/company/set-backends
                      '((company-shell
                         company-shell-env
                         company-yasnippet)
                        (company-files)))

                     ;; set flycheck backends
                     (eos/flycheck/set-checker 'sh-shellcheck)))))

     #+END_SRC

**** Company-shell

     #+BEGIN_SRC emacs-lisp

     (require 'company-shell nil t)

     #+END_SRC

*** Fish
**** Fish-mode

     #+BEGIN_SRC emacs-lisp

     (when (require 'fish-mode nil t)
       (progn
         ;; hooks
         (add-hook 'fish-mode-hook
                   (lambda ()
                     ;; set company backends
                     (eos/company/set-backends
                      '((company-fish-shell
                         company-yasnippet
                         company-shell
                         company-shell-env)
                        (company-files)))))))

     #+END_SRC

*** Lua
**** Lua-mode

     #+BEGIN_SRC emacs-lisp

     (when (require 'lua-mode nil t)
       (progn
         ;; custom
         ;; non-nil means display lua-process-buffer after sending a command.
         (customize-set-variable 'lua-process-buffer t)

         ;; default application to run in Lua process
         (customize-set-variable 'lua-default-application "lua")

         ;; command switches for lua-default-application
         (customize-set-variable 'lua-default-command-switches "-i")

         ;; amount by which Lua subexpressions are indented
         (customize-set-variable 'lua-indent-level 4)

         ;; if non-nil, contents of multiline string will be indented
         (customize-set-variable 'lua-indent-string-contents t)

         ;; jump to innermost traceback location in *lua* buffer
         ;; when this variable is non-nil and a traceback occurs
         ;; when running Lua code in a process, jump immediately
         ;; to the source code of the innermost traceback location
         (customize-set-variable 'lua-jump-on-traceback t)

         ;; hooks
         (add-hook 'lua-mode-hook
                   (lambda ()
                     ;; set company backends
                     (eos/company/set-backends
                      '((company-yasnippet
                         company-keywords
                         company-gtags
                         company-dabbrev-code
                         company-keywords)
                        (company-files)))

                     ;; set flycheck checker
                     (eos/flycheck/set-checker 'lua)

                     ;; activate dash docset
                     (eos/dash/activate-docset "Lua")))

         ;; add auto-mode
         (add-to-list 'auto-mode-alist '("\\.lua$" . lua-mode))
         (add-to-list 'interpreter-mode-alist '("lua" . lua-mode))))

     #+END_SRC

*** Tcl
**** Tcl

     #+BEGIN_SRC emacs-lisp

     (require 'tcl nil t)

     #+END_SRC

*** Perl
**** Cperl-mode

     #+BEGIN_SRC emacs-lisp

     (require 'cperl-mode nil t)

     #+END_SRC

*** Python

    Syntax highlighting, Indentation, Movement, Shell
    interaction, Shell completion, Shell virtualenv support, Shell
    package support, Shell syntax highlighting, Pdb tracking, Symbol
    completion, Skeletons, FFAP, Code Check, Eldoc, Imenu.

    #+BEGIN_SRC emacs-lisp

    (when (require 'python nil t)
      (progn
        ;; custom
        ;; default Python interpreter for shell
        (customize-set-variable 'python-shell-interpreter "python2.7")

        ;; non-nil means template skeletons will be automagically inserted
        (customize-set-variable 'python-skeleton-autoinsert t)

        ;; hooks
        ;; enable modes
        (add-hook 'python-mode-hook
                  (lambda()
                    ;; enable eldoc mode
                    (eos/funcall 'eldoc-mode 1)))

        ;; set backends
        (add-hook 'python-mode-hook
                  (lambda ()
                    ;; set company backends
                    (eos/company/set-backends
                     '((company-yasnippet
                        company-keywords
                        company-dabbrev-code)
                       (company-files)))

                    ;; set flycheck checker
                    (eos/flycheck/set-checker 'python-pycompile)

                    ;; set dash docsets
                    (eos/dash/activate-docset '"Python 3")))))

    #+END_SRC

*** Go
**** Go-mode

     #+BEGIN_SRC emacs-lisp

     (when (require 'go-mode nil t)
       (progn
         ;; add (*.go . go-mode) to auto-mode-alist
         ;; init go-mode when a file with the extersion .go is opened
         (add-to-list 'auto-mode-alist '("\\.go\\'" . go-mode))

         ;; hooks
         (add-hook 'go-mode-hook
                   (lambda ()
                     ;; set company backends
                     (eos/company/set-backends
                      '((company-yasnippet
                         company-keywords
                         company-dabbrev-code)
                        (company-files)))

                     ;; set flycheck checker (go lint)
                     (eos/flycheck/set-checker 'go-golint)

                     ;; set dash docsets
                     (eos/dash/activate-docset '"Go")))))

     #+END_SRC

*** R
**** Ess-R

     #+BEGIN_SRC emacs-lisp

     (require 'ess-r-mode nil t)

     #+END_SRC

*** Julia
**** Julia-mode

     #+BEGIN_SRC emacs-lisp

     (require 'julia-mode nil t)

     #+END_SRC

**** Ess-julia

     #+BEGIN_SRC emacs-lisp

     (require 'ess-julia nil t)

     #+END_SRC

*** Clojure
*** Vhdl
**** Vhdl-mode

     #+BEGIN_SRC emacs-lisp

     (require 'vhdl-mode nil t)

     #+END_SRC

*** Verilog
**** Verilog

     #+BEGIN_SRC emacs-lisp

     (require 'verilog nil t)

     #+END_SRC

*** Cmake
**** Cmake-mode

     Enables cmake mode for editing cmake files.

     #+BEGIN_SRC emacs-lisp

     (require 'cmake-mode nil t)

     #+END_SRC

*** Mql
**** Mql-mode

     #+BEGIN_SRC emacs-lisp

     (add-to-list 'load-path
                  (concat user-emacs-directory "elpa/mql-mode"))

     (when (require 'mql-mode nil t)
       (progn
         ;; hooks
         (add-hook 'mql-mode-hook
                   (lambda ()
                     ;; set company backends
                     (eos/company/set-backends
                      '((company-gtags
                         company-yasnippet)
                        (company-files)))

                     ;; select flycheck checker (use gcc)
                     (eos/flycheck/set-checker 'c/c++-gcc)

                     ;; activate mql5 docset
                     (eos/dash/activate-docset '"mql5")))))

     #+END_SRC

*** Doxygen
**** Highlight-doxygen

     Mode for highlight doxygen sections and its keywords.

     #+BEGIN_SRC emacs-lisp

     (when (require 'highlight-doxygen nil t)
       (progn
         ;; add doxygen
         (add-hook 'prog-mode-hook 'highlight-doxygen-global-mode)
         ;; change background color of comment block
         (custom-set-faces
           '(highlight-doxygen-comment ((t (:inherit font-lock-doc-face :background "grey3")))))))

     #+END_SRC

*** Web
**** Web-mode

     #+BEGIN_SRC emacs-lisp

     (when (require 'web-mode nil t)
       (progn
         ;; add files extensions to web-mode
         (add-to-list 'auto-mode-alist '("\\.php\\'" . web-mode))
         (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
         (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
         (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
         (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
         (add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
         (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))))

     (when (boundp 'web-mode-engines-alist)
       (progn
         (add-to-list 'web-mode-engines-alist '(("php" . "\\.phtml\\'")))))

     #+END_SRC

** Unbind
*** Prefix
**** Esc

     Quality of life.

     #+BEGIN_SRC emacs-lisp

     ;; clean esc map
     (define-key esc-map (kbd "ESC") nil)
     (define-key esc-map (kbd "<f10>") nil)

     #+END_SRC

**** Ctl-x

     Quality of life.

     #+BEGIN_SRC emacs-lisp

     ;; unbind
     ;; (define-key ctl-x-map (kbd "C-SPC") nil)
     ;; (define-key ctl-x-map (kbd "C-=") nil)
     ;; (define-key ctl-x-map (kbd "C-0") nil)
     ;; (define-key ctl-x-map (kbd "C-z") nil)
     ;; (define-key ctl-x-map (kbd "C--") nil)
     ;; (define-key ctl-x-map (kbd "ESC") nil)
     ;; (define-key ctl-x-map (kbd ".") nil)
     ;; (define-key ctl-x-map (kbd "C-l") nil)
     (define-key ctl-x-map (kbd "C-d") nil)
     (define-key ctl-x-map (kbd "C-<left>") nil)
     (define-key ctl-x-map (kbd "C-<right>") nil)
     (define-key ctl-x-map (kbd "C-<up>") nil)
     (define-key ctl-x-map (kbd "C-<down>") nil)
     (define-key ctl-x-map (kbd "<right>") nil)
     (define-key ctl-x-map (kbd "<left>") nil)
     (define-key ctl-x-map (kbd "C-+") nil)
     (define-key ctl-x-map (kbd "C-a") nil)
     (define-key ctl-x-map (kbd "C-r") nil)
     (define-key ctl-x-map (kbd "C-n") nil)
     (define-key ctl-x-map (kbd "C-p") nil)
     (define-key ctl-x-map (kbd "C-o") nil)
     (define-key ctl-x-map (kbd "C-h") nil)
     (define-key ctl-x-map (kbd "C-u") nil)
     (define-key ctl-x-map (kbd "C-\@") nil)
     (define-key ctl-x-map (kbd "M-:") nil)
     (define-key ctl-x-map (kbd "`") nil)
     (define-key ctl-x-map (kbd "]") nil)
     ;; (define-key ctl-x-map (kbd "[") nil)
     (define-key ctl-x-map (kbd ")") nil)
     (define-key ctl-x-map (kbd "(") nil)
     (define-key ctl-x-map (kbd "<") nil)
     (define-key ctl-x-map (kbd ">") nil)
     (define-key ctl-x-map (kbd "\@") nil)
     (define-key ctl-x-map (kbd "-") nil)
     (define-key ctl-x-map (kbd ";") nil)
     (define-key ctl-x-map (kbd "#") nil)
     (define-key ctl-x-map (kbd "*") nil)
     (define-key ctl-x-map (kbd "'") nil)
     (define-key ctl-x-map (kbd "$") nil)
     (define-key ctl-x-map (kbd "{") nil)
     (define-key ctl-x-map (kbd "}") nil)
     (define-key ctl-x-map (kbd "^") nil)
     (define-key ctl-x-map (kbd "n") nil)
     (define-key ctl-x-map (kbd "f") nil)
     (define-key ctl-x-map (kbd "a") nil)
     (define-key ctl-x-map (kbd "h") nil)
     (define-key ctl-x-map (kbd "v") nil)

     #+END_SRC

*** Minor

    Clean minor-mode-map-alist.

    #+BEGIN_SRC emacs-lisp

    ;; clean minor-mode-map-alist
    (setq minor-mode-map-alist nil)

    #+END_SRC

*** Global

    Quality of life.

    #+BEGIN_SRC emacs-lisp

    ;; unset
    (global-unset-key (kbd "C-z"))
    (global-unset-key (kbd "C-@"))
    (global-unset-key (kbd "C-\\"))
    (global-unset-key (kbd "C-_"))
    (global-unset-key (kbd "M-l"))
    (global-unset-key (kbd "M-h"))
    (global-unset-key (kbd "M-\\"))
    (global-unset-key (kbd "M-$"))
    (global-unset-key (kbd "M-("))
    (global-unset-key (kbd "M-)"))
    (global-unset-key (kbd "M-r"))
    (global-unset-key (kbd "M-{"))
    (global-unset-key (kbd "M-}"))
    (global-unset-key (kbd "S-SPC"))
    (global-unset-key (kbd "<backtap>"))
    (global-unset-key (kbd "M-="))
    (global-unset-key (kbd "M-@"))
    (global-unset-key (kbd "M-~"))

    ;; (global-unset-key (kbd "M-z"))
    ;; (global-unset-key (kbd "M-SPC"))
    ;; (global-unset-key (kbd "M-m"))
    ;; (global-unset-key (kbd "M-k"))
    ;; (global-unset-key (kbd "M-t"))
    ;; (global-unset-key (kbd "M-q"))

    (global-unset-key (kbd "C-M-h"))
    (global-unset-key (kbd "C-M-j"))
    (global-unset-key (kbd "C-M-."))
    (global-unset-key (kbd "C-M-l"))
    (global-unset-key (kbd "C-M-/"))
    (global-unset-key (kbd "C-M-;"))
    (global-unset-key (kbd "C-M-@"))
    (global-unset-key (kbd "C-M-\\"))
    (global-unset-key (kbd "C-M-a"))
    (global-unset-key (kbd "C-M-r"))
    (global-unset-key (kbd "C-M-s"))
    (global-unset-key (kbd "C-M-%"))
    (global-unset-key (kbd "C-M-u"))
    (global-unset-key (kbd "C-M-d"))
    (global-unset-key (kbd "C-M-SPC"))
    (global-unset-key (kbd "C-M-S-v"))

    (global-unset-key (kbd "<C-M-end>"))
    (global-unset-key (kbd "<C-M-home>"))
    (global-unset-key (kbd "<C-S-backspace>"))
    (global-unset-key (kbd "<C-backspace>"))
    (global-unset-key (kbd "<C-delete>"))
    (global-unset-key (kbd "<C-down>"))
    (global-unset-key (kbd "<C-next>"))
    (global-unset-key (kbd "<C-end>"))
    (global-unset-key (kbd "<C-f10>"))
    (global-unset-key (kbd "<M-f10>"))

    (global-unset-key (kbd "<bottom-divider>"))
    (global-unset-key (kbd "<bottom-edge>"))
    (global-unset-key (kbd "<bottom-left-corner>"))
    (global-unset-key (kbd "<bottom-right-corner>"))

    (global-unset-key (kbd "<horizontal-scroll-bar>"))
    (global-unset-key (kbd "<vertical-scroll-bar>"))

    (global-unset-key (kbd "<left-edge>"))
    (global-unset-key (kbd "<right-edge>"))

    (global-unset-key (kbd "<undo>"))
    (global-unset-key (kbd "<find>"))
    (global-unset-key (kbd "<help>"))
    (global-unset-key (kbd "<open>"))
    (global-unset-key (kbd "<again>"))
    (global-unset-key (kbd "<menu>"))
    (global-unset-key (kbd "<header-line>"))
    (global-unset-key (kbd "<mode-line>"))

    (global-unset-key (kbd "<XF86Back>"))
    (global-unset-key (kbd "<XF86Forward>"))
    (global-unset-key (kbd "<XF86WakeUp>"))

    (global-unset-key (kbd "<top-edge>"))
    (global-unset-key (kbd "<top-left-corner>"))
    (global-unset-key (kbd "<top-right-corner>"))

    (global-unset-key (kbd "<f10>"))
    (global-unset-key (kbd "<f11>"))
    (global-unset-key (kbd "<f16>"))
    (global-unset-key (kbd "<f18>"))
    (global-unset-key (kbd "<f20>"))

    #+END_SRC

** Adapt

   #+BEGIN_SRC emacs-lisp

   (require 'eos-adapt
            (expand-file-name "eos-adapt.el" user-emacs-directory) t)

   #+END_SRC

** EOF

   "See You Space Cowboy.."
   | Cowboy Bebop |
